java
    3.泛型的使用
        确认泛型
            在创建对象的时候确定泛型
        ArrayList<String> list = new ArrayList<String>();
            此时，变量E的值就是String类型,那么我们的类型就可以理解为：
        ArrayList<Integer> list = new ArrayList<Integer>();
            此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：
        举例自定义泛型类
            使用:
        3. 泛型的定义
            再名字后面
                1,含有泛型的类
                    定义格式：修饰符 class 类名<代表泛型的变量> {
                    例如，API中的ArrayList集合：
                3,含有泛型的接口
                    修饰符 interface接口名<代表泛型的变量> {  }
                    1、定义类时确定泛型的类型
                        例如
                            此时，泛型E的值就是String类型。
                    2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型
                        例如
                            确定泛型：
            在名子前面
                2,含有泛型的方法
                    修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }
                        例如，
                        使用格式：
                        调用方法时，确定泛型的类型
    泛型标识符
         N - Number（数值类型）
        集合类型
            E - Element (在集合中使用，因为集合中存放的是元素)
             K - Key（键）
             V - Value（值）
         T - Type（Java 类）
        ？ -  表示不确定的java类型
            4. 泛型通配符
                分类
                    未知通配符
                        只能接收数据，不能往集合中存储数据
                    泛型的上限
                        格式： 类型名称 <? extends 类 > 对象名称
                        意义： 只能接收该类型及其子类
                    泛型的下限
                        格式： 类型名称 <? super 类 > 对象名称
                        意义： 只能接收该类型及其父类型
        <T> CommonResult<T>
            缺少前面的T会编译失败
    2. 使用泛型的好处
        泛型的好处：
            避免了类型强转的麻烦。
            将运行时期的ClassCastException，转移到了编译时期变成了编译失败。
        好处
            类型安全
            提供编译期间的类型检测
            前后兼容
            泛化代码,代码可以更多的重复利用
            性能较高
            用GJ(泛型JAVA)编写的代码可以为java编译器和虚拟机带来更多的类型信息