#########################################################
第七篇 嵌入式Linux驱动开发基础知识	374
	第一章 嵌入式后Linux驱动开发基础知识的引导与说明	374
		1.1 打算讲什么、怎么讲？	374
		1.2 需要做什么准备工作	375
			1，开发板接线
			3，开发板烧写
			4，下载linux内核，
			5，windows source insight看写，linux编译
			6，ubuntu安装编译工具链
			1，ubuntu配置，编译开发板的linux内核

	第二章 Hello驱动(不涉及硬件操作)	376
		2.1  APP打开的文件在内核中如何表示	376
			打开文件时，内核会记录flag model
		2.2  打开字符设备节点时，内核中也有对应的struct file	377
		2.3  请猜猜怎么编写驱动程序	377
		2.4  请不要啰嗦，表演你的代码吧	378
			2.4.1 写驱动程序	378 emmmmmmmmmmmmmx
			 		### A,驱动file_operation 实现open，write，read，release 
					### hello_init 安装驱动
					### hello_exit 驱动卸载
					### module_exit module_init MODULE_LICENSE
					### B,调用：传入的数据保存在驱动
					### C,驱动返回数据给APP
			2.4.2 写测试程序	381 emmmmmmmmmmmmmmmmmmx
					### A，编写驱动程序的makefile
					### B, 上机实验，程序通过NFS挂在ubuntu执行
                    ### C, 虚拟机实验，
			2.4.3 测试	382
					### makefile特定
					### 执行对应的insmod和 rmmod
					### dmseg查看 (ubuntu中)
		2.5  Hello驱动中的一些补充知识	384
			2.5.1 module_init/module_exit的实现	384
			2.5.2 register_chrdev的内部实现	384
			2.5.3 class_destroy/device_create浅析	384

	第三章 硬件知识_LED原理图	385
		3.1 先来讲讲怎么看原理图	385

	第四章 普适的GPIO引脚操作方法	387
		4.1 GPIO模块一般结构	387
				### a.多组GPIO -》多个GPIO
				### b.使能：电源使能/时钟使能PRCM
				### c.模式：
				### d.方向，输入还是输出
				### e.数值：输出引脚，高低电平
						输入引脚，读取电平
		4.2 GPIO寄存器操作	388
				### a,没有使能开关：一直使能
				### b.选择多种功能：串口，USB
				### c.方向寄存器
				### d.数据寄存器
				### e.clear and set
				### f. | &  
		4.3 GPIO的其他功能：防抖动、中断、唤醒	388

	第五章 具体单板的GPIO操作方法	389
		5.1 AM335X的GPIO操作方法	389
			5.1.1 AM335X的GPIO模块结构	390
				### 4组GPIO 32个
				### PRCM使能寄存器
				### Control Module设置模式
				### Control Module设置GPIO输入引脚，输入引脚
			5.1.2 AM335X的GPIO相关寄存器	391
			5.1.3 set-and-clear协议	392
		5.2 RK3288的GPIO操作方法	393
			5.2.1 RK3288的GPIO模块结构	394
				### GPIO通用输入输出口
				### CRU 时钟和复位单元
				### PMU 电源管理单元
				### GRF 通用寄存器文件
			5.2.2 RK3288的GPIO相关寄存器	396
				### 9组 4小组 8个GPIO
				### CRU_CLKGATE17_CON
				### CRU_CLKGATE!$_CON
				### 
		5.3 RK3399的GPIO操作方法	397
			5.3.1 RK3399的GPIO模块结构	397
				### GPIO: General-purpose input/output，通用的输入输出口
				### CRU: Clock & Reset Unit (时钟和复位单元)
				### PMU: Power Managerment Unit (电源管理单元)
				### GRF: General Register Files (通用寄存器文件)
			5.3.2 RK3399的GPIO相关寄存器	399
				### 5组 4小组 8个GPIO
		5.4 IMX6ULL的GPIO操作方法	400
			5.4.1 IMX6ULL的GPIO模块结构	400
				### CCM: Clock Controller Module (时钟控制模块)
				### IOMUXC : IOMUX Controller，IO 复用控制器
				### GPIO: General-purpose input/output，通用的输入输出口
			5.4.2 CCM用于设置是否向GPIO模块提供时钟	401
			5.4.3 IOMUXC：引脚的模式(Mode、功能)	402
				### 选择功能
				### 设置上下拉电阻等参数：使能; 输出方式；驱动能力....
			5.4.4 GPIO模块内部	405
				### GPIOx_GDIR: 设置引脚方向
				### GPIOx_GDIR: 设置输出引脚电平
				### GPIOx_PSR: 读取引脚的电平
			5.4.5 怎么编程	407
				5.4.5.1 读GPIO	407
				5.4.5.2 写GPIO	408

	第六章 LED驱动程序框架	409
		6.1  回顾字符设备驱动程序框架	409
			### 1，确定主设备号/让内核分配
			### 2，定义自己的file_operation结构体
			### 3，实现对应的drv_operation结构体
			### 4，file_operation告诉内核 register_chrdev
			### 5, 入口函数register_chrdev 注册驱动程序
			### 6，出口函数unregister_chrdev 卸载驱动程序
			### 7，创建设备节点
		6.2  对于LED驱动，我们想要什么样的接口？	410
		6.3  LED驱动要怎么写，才能支持多个板子？分层。	410
			### 拆分：
				通用框架 leddrv.c 类似接口
				硬件操作 board_X.c 类似实现
		6.4  写代码	411
			6.4.1 驱动程序	411
				6.4.1.1 把LED的操作抽象出一个led_operations结构体	411
				6.4.1.2 驱动程序的上层：file_operations结构体	411
			6.4.2 测试程序	413
			6.4.3 上机测试	415
		6.5  课后作业	416

	第七章 具体单板的LED驱动程序	416
		7.0  怎么写LED驱动程序？	416
			### 原理图：
			### 芯片手册：
			### 驱动：框架+驱动代码
				### 物理地址到虚拟地址
		7.1  AM335X的LED驱动程序	418
			7.1.1 原理图	418
			7.1.2 所涉及的寄存器操作	418
			7.1.3 写程序	421
			7.1.4配置内核去掉原有LED驱动	424
			7.1.5 课后作业	424
		7.2  RK3288和RK3399的LED驱动程序	424
			7.2.1 原理图	424
				7.2.1.1 fireflye RK3288的LED原理图	424
				7.2.1.2 firefly RK3399的LED原理图	425
			7.2.2 所涉及的寄存器操作	425
				7.2.2.1 RK3288的GPIO8_A1引脚	426
				7.2.2.2 RK3399的GPIO2_D3引脚	429
			7.2.3 写程序	431
				7.2.3.1 RK3288	431
				7.2.3.2 RK3399	433
			7.2.4 上机实验	436
				7.2.4.1 RK3288	436
				7.2.4.2 RK3399	436
			7.2.5 课后作业	436
		7.3  野火/正点原子IMX6ULL的LED驱动程序	437
			7.3.1 原理图	437
				7.3.1.1 野火fire_imx6ull-pro开发板	437
				7.3.1.2 正点原子Atk_imx6ull-alpha开发板	437
			7.3.2 所涉及的寄存器操作	438
				7.3.2.1 野火fire_imx6ull-pro开发板	439
				7.3.2.2 正点原子Atk_imx6ull-alpha开发板	442
			7.3.3 写程序	445
				7.3.3.1 野火fire_imx6ull-pro开发板	445
				7.3.3.2 正点原子Atk_imx6ull-alpha开发板	448
			7.3.4 上机实验	451
				7.3.4.1 野火fire_imx6ull-pro开发板	451
				7.3.4.2 正点原子Atk_imx6ull-alpha开发板	452
			7.3.5 课后作业	452
		7.4 百问网IMX6ULL-QEMU的LED驱动程序	453
			7.4.1 看原理图确定引脚及操作方法	454
			7.4.2 所涉及的寄存器操作	455
			7.4.3 写程序	459
			7.4.4 上机实验	463
			7.4.5 课后作业	
			
	第八章 驱动设计的思想：面向对象/分层/分离	464
		8.1  面向对象	464
		8.2  分层	464
		8.3  分离	464
		8.4  写示例代码	466/
		8.5  课后作业	467
	第九章 驱动进化之路：总线设备驱动模型	468
		9.1  驱动编写的3种方法	468
			9.1.1 传统写法	469
			9.1.2 总线设备驱动模型	469
			9.1.3 设备树	470
		9.2  在Linux中实现“分离”：Bus/Dev/Drv模型	470
		9.3  匹配规则	471
			9.3.1 最先比较：platform_device. driver_override和platform_driver.driver.name	471
			9.3.2 然后比较：platform_device. name和platform_driver.id_table[i].name	471
			9.3.3 最后比较：platform_device.name和platform_driver.driver.name	471
			9.3.4 函数调用关系	471
		9.5  常用函数	472
			9.5.1 注册/反注册	472
			9.5.2 获得资源	472
		9.6  怎么写程序	473
			9.6.1 分配/设置/注册platform_device结构体	473
			9.6.2 分配/设置/注册platform_driver结构体	473
		9.7  课后作业	473
	第十章 LED模板驱动程序的改造：总线设备驱动模型	474
		10.1  原来的框架	474
		10.2  要实现的框架	475
		10.3  写代码	475
			10.3.1 注意事项	475
			10.3.2 实现platform_device结构体	476
			10.3.3 实现platform_driver结构体	478
		10.4  课后作业	481
	
	第十一章 驱动进化之路：设备树的引入及简明教程	482
		11.1  设备树的引入与作用	482
		11.2  设备树的语法	483
			11.2.1 Devicetree格式	484
				11.2.1.1 DTS文件的格式	484
				11.2.1.2 node的格式	484
				11.2.1.3 properties的格式	485
			11.2.2 dts文件包含dtsi文件	486
			11.2.3 常用的属性	486
				11.2.3.1 #address-cells、#size-cells	486
				11.2.3.2 compatible	487
				11.2.3.3 model	487
				11.2.3.4 status	487
				11.2.3.5 reg	488
				11.2.3.6 name(过时了，建议不用)	488
				11.2.3.7 device_type(过时了，建议不用)	488
			11.2.4 常用的节点(node)	488
				11.2.4.1 根节点	488
				11.2.4.2 CPU节点	489
				11.2.4.3 memory节点	489
				11.2.4.4 chosen节点	489
		11.3  编译、更换设备树	490
			11.3.1 在内核中直接make	490
			11.3.2 手工编译	490
			11.3.3 给开发板更换设备树文件	491
				11.3.3.1 对于100ask-am335x 单板	491
				11.3.3.2 对于firefly-rk3288	491
				11.3.3.3 对于firefly的roc-rk3399-pc	491
				11.3.3.4 对于百问网使用QEMU模拟的IMX6ULL板子	491
				11.3.3.5 对于野火imx6ull-pro	491
				11.3.3.6 对于正点原子imx6ull-alpha	491
			11.3.4 板子启动后查看设备树	492
		11.4  内核对设备树的处理	492
			11.4.1 dtb中每一个节点都被转换为device_node结构体	493
			11.4.2 哪些设备树节点会被转换为platform_device	493
			11.4.3 怎么转换为platform_device	494
		11.5 platform_device如何与platform_driver配对	494
			11.5.1 最先比较：是否强制选择某个driver	495
			11.5.2 然后比较：设备树信息	495
			11.5.3 接下来比较：platform_device_id	496
			11.5.4 最后比较：platform_device.name和platform_driver.driver.name	496
			11.5.5 一个图概括所有的配对过程	497
		11.6 没有转换为platform_device的节点，如何使用	497
		11.7  内核里操作设备树的常用函数	498
			11.7.1 内核中设备树相关的头文件介绍	498
				11.7.1.1 处理DTB	498
				11.7.1.2 处理device_node	498
				11.7.1.3 处理 platform_device	498
			11.7.2 platform_device相关的函数	499
				11.7.2.1 of_find_device_by_node	499
				11.7.2.2 platform_get_resource	499
			11.7.3 有些节点不会生成platform_device，怎么访问它们	499
				11.7.3.1 找到节点	500
				11.7.3.2 找到属性	502
				11.7.3.3 获取属性的值	503
		11.8  怎么修改设备树文件	506
			11.8.1 使用芯片厂家提供的工具	506
			11.8.2 看绑定文档	506
			11.8.3 参考同类型单板的设备树文件	506
			11.8.4 网上搜索	506
			11.8.5 实在没办法时, 只能去研究驱动源码	506
	第十二章 LED模板驱动程序的改造：设备树	507
		12.1  总结3种写驱动程序的方法	507
		12.2  怎么使用设备树写驱动程序	508
			12.2.1 设备树节点要与platform_driver能匹配	508
			12.2.2 设备树节点指定资源，platform_driver获得资源	508
		12.3  开始编程	509
			12.3.1 修改设备树添加led设备节点	509
				12.3.1.1 对于100ask-am335x 单板	509
				12.3.1.2 对于firefly-rk3288	509
				12.3.1.3 对于firefly的roc-rk3399-pc	509
				12.3.1.4 对于百问网使用QEMU模拟的IMX6ULL板子	510
				12.3.1.5 对于野火imx6ull-pro	510
				12.3.1.6 对于正点原子imx6ull-alpha	510
			12.3.2 修改platform_driver的源码	510
		12.4  上机实验	511
		12.5  调试技巧	512
			12.5.1 设备树的信息	512
			12.5.2 platform_device的信息	512
			12.5.3 platform_driver的信息	513
		12.6  课后作业	513
	第十三章 APP怎么读取按键值	514
		13.1  妈妈怎么知道孩子醒了	514
		########## 重要 ######### 
		13.2  APP读取按键的4种方法	515
			13.2.1 查询方式	515
				### 图
			13.2.2 休眠-唤醒方式	516
			13.2.3 poll方式	516
			13.2.4 异步通知方式	517
				13.2.4.1 异步通知的原理：发信号	517
				13.2.4.2 应用程序之间发信号示例代码	518
			13.2.5 驱动程序提供能力，不提供策略	519
	第十四章 查询方式的按键驱动程序_编写框架	519
		14.1  LED驱动回顾	519
		14.2  按键驱动编写思路	519
		14.3  编程：先写框架	521
			### 14.3.1 把按键的操作抽象出一个button_operations结构体	521
			### 14.3.2 驱动程序的上层：file_operations结构体	522
		14.4  测试	524
		14.5  课后怎业	524
	第十五章 具体单板的按键驱动程序(查询方式)	524
		15.0  GPIO操作回顾	524
		15.1  AM335X的按键驱动程序(查询方式)	525
			15.1.1 先看原理图确定引脚及操作方法	525
			15.1.2 再看芯片手册确定寄存器及操作方法	526
			15.1.3 编程	528
				15.1.3.1 程序框架	528
				15.1.3.2 硬件相关的代码	528
			15.1.4 测试	530
			15.1.5 课后作业	530
		15.2  RK3288的按键驱动程序(查询方式)	531
			15.2.1 先看原理图确定引脚及操作方法	531
			15.2.2 再看芯片手册确定寄存器及操作方法	532
			15.2.3 编程	535
				15.2.3.1 程序框架	535
				15.2.3.2 硬件相关的代码	535
			15.2.4 测试	537
			15.2.5 课后作业	537
		15.3  RK3399的按键驱动程序(查询方式)	537
			15.3.1 先看原理图确定引脚及操作方法	537
			15.3.2 再看芯片手册确定寄存器及操作方法	538
			15.3.3 编程	541
				15.3.3.1 程序框架	541
				15.3.3.2 硬件相关的代码	542
			15.3.4 测试	543
			15.3.5 课后作业	544
		15.4  百问网IMX6ULL-QEMU的按键驱动程序(查询方式)	544
			15.4.1 先看原理图确定引脚及操作方法	544
			15.4.2 再看芯片手册确定寄存器及操作方法	545
			15.4.3 编程	549
				15.4.3.1 程序框架	549
				15.4.3.2 硬件相关的代码	549
			15.4.4 测试	552
			15.4.5 课后作业	553
	第十六章 GPIO和Pinctrl子系统的使用	553
		16.1 Pinctrl子系统重要概念	553
			16.1.1 引入	553
			16.1.2 重要概念	555
			16.1.3 示例	556
			16.1.4 代码中怎么引用pinctrl	556
		16.2 GPIO子系统重要概念	557
			16.2.1 引入	557
			16.2.2 在设备树中指定引脚	557
			16.2.3 在驱动代码中调用GPIO子系统	559
			16.2.4 sysfs中的访问方法	561
		16.3 基于GPIO子系统的LED驱动程序	562
			16.3.1 编写思路	562
			16.3.2 在设备树中添加Pinctrl信息	563
			16.3.3 在设备树中添加GPIO信息	564
			16.3.4编程示例	565
		16.4 在100ASK_IMX6ULL上机实验	567
			16.4.1 确定引脚并生成设备树节点	567
			16.4.2 编译程序	569
	第十七章 异常与中断的概念及处理流程	569
		17.1  中断的引入	569
			17.1.1 妈妈怎么知道孩子醒了	569
			17.1.2 嵌入系统中也有类似的情况	571
		17.2  中断的处理流程	571
		17.3  异常向量表	572
		17.4  参考资料	573
	第十八章 Linux系统对中断的处理	573
		18.1  进程、线程、中断的核心：栈	573
			18.1.1 ARM处理器程序运行的过程	573
			18.1.2 程序被中断时，怎么保存现场	575
			18.1.3 进程、线程的概念	576
		18.2  Linux系统对中断处理的演进	579
			18.2.1 Linux对中断的扩展：硬件中断、软件中断	579
			18.2.2 中断处理原则1：不能嵌套	581
			18.2.3 中断处理原则2：越快越好	581
			18.2.4 要处理的事情实在太多，拆分为：上半部、下半部	581
			18.2.5 下半部要做的事情耗时不是太长：tasklet	582
			18.2.6 下半部要做的事情太多并且很复杂：工作队列	584
			18.2.7 新技术：threaded irq	585
		18.3  Linux中断系统中的重要数据结构	586
			18.3.1 irq_desc数组	587
			18.3.2 irqaction结构体	588
			18.3.3 irq_data结构体	589
			18.3.4 irq_domain结构体	589
			18.3.5 irq_chip结构体	590
		18.4  在设备树中指定中断_在代码中获得中断	591
			18.4.1 设备树里中断节点的语法	591
				18.4.4.1 设备树里的中断控制器	591
				18.4.4.2 设备树里使用中断	592
			18.4.2 设备树里中断节点的示例	593
			18.4.3 在代码中获得中断	594
				18.4.3.1 对于platform_device	594
				18.4.3.2 对于I2C设备、SPI设备	594
				18.4.3.3 调用of_irq_get获得中断号	595
				18.4.3.4 对于GPIO	595
		18.5 编写使用中断的按键驱动程序	597
			18.5.1  编程思路	597
				18.5.1.1 设备树相关	597
				18.5.1.2 驱动代码相关	597
			18.5.2 先编写驱动程序	597
				18.5.2.1 从设备树获得GPIO	597
				18.5.2.1 从GPIO获得中断号	598
				18.5.2.2 申请中断	598
				18.5.2.3 中断函数	598
		18.6  IMX6ULL设备树修改及上机实验	598
			18.6.1 查看原理图确定按键引脚	598
			18.6.2 修改设备树	598
			18.6.3 上机实验	600
	第十九章 常见问题	602
		1.  安装驱动时version magic不匹配	602
