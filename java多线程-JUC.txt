juc
    2. JUC
        并发容器
            BlockingQueue
                说明
                    在所有的并发容器中，BlockingQueue是最常见的一种
                    它是一个带阻塞功能的队列，当入队列时，若队列已满，则阻塞调用者，当出队列时，若队列为空，则阻塞调用者
                    在Concurrent包中，BlockingQueue是一个接口，有许多不同的实现类
                ArrayBlockingQueue
                    一个用数组实现的环形队列，在构造方法中，会要求传入数组的容量
                LinkedBlockingQueue
                    一种基于单向链表的阻塞队列，因为队头和队尾是2个指针分开操作的，所以用了2把锁+2个条件，同时有一个AtomicInteger的原子变量记录count数
                    构造方法中，可以指定队列的总容量，如果不指定，默认为Integer.MAX_VALUE
                    区别于ArrayBlockingQueue
                        1、为了提高并发度，用了2把锁，分别控制队头、队尾的操作
                            意味着在put()和put()之间、take()和take()之间是互斥的，put()和take()之间并不互斥
                            但对于count变量，双方都需要操作，所以必须是原子变量
                        2、因为各自拿了一把锁，所以当需要调用对方的condition的signal时，还必须再加上对方的锁，就是signalNotEmpty()和signalNotFull()
                        3、不仅put会通知take，take也会通知put
                            当put发现非满时，也会通知其他put线程
                            当take发现非空时，也会通知其他take线程
                PriorityBlockingQueue
                    队列通常是先进先出的，而该队列是按照元素优先级从小到大出队列的
                        因此，队列元素之间需要可以比较大小，并实现Comparable接口
                    构造方法中，如果不指定初始大小，内部会设定一个默认值11，当元素个数超过该值，会自动扩容
                    阻塞的实现方面，和ArrayBlockingQueue机制类似
                        主要区别是用数组实现了一个二叉堆，从而实现按优先级从小到大出队列
                        另一个区别是没有notFull条件，当元素个数超过数组长度，执行扩容操作
                DelayQueue
                    即延迟队列，一个按延迟时间从小到大出列的PriorityQueue
                    放入该队列的元素，必须实现Delayed接口
                        1、如果getDelay的返回值小于等于0，则说明该元素到期，需要从队列中拿出来执行
                        2、该接口首先继承了Comparable接口，所以要实现该接口，必须实现Comparable接口
                SynchronousQueue
                    一种特殊的BlockingQueue，它本身没有容量
                        先调put()，线程会阻塞；直到另一个线程调用了take()，两个线程才同时解锁，反之亦然
            BlockingDeque
                定义了一个阻塞的双端队列接口，继承了BlockingQueue接口，同时增加了对应的双端队列操作接口
                该接口仅有一个实现：LinkedBlockingDeque，底层使用了一个双向链表
            CopyOnWrite
                说明
                    指在“写”时，不是直接“写”源数据，而是把数据拷贝一份进行修改，再通过悲观锁或乐观锁的方式写回
                    这是为了在“读”的时候不加锁
                CopyOnWriteArrayList
                    核心数据结构也是一个数组
                CopyOnWriteArraySet
                    用Array实现的一个Set，保证所有元素都不重复，其内部是封装的一个CopyOnWriteArrayList
            ConcurrentLinkedQueue/Deque
                实现原理
                    和AQS内部的阻塞队列类似，同样是基于CAS，通过head/tail指针记录队列头部和尾部，实现入队和出队
                    首先，它是一个单向链表
                    其次，在AQS的阻塞队列中，每次入队后，tail一定后移一个位置，每次出队，head一定后移一个位置，以保证head指向队列头部，tail指向链表尾部
                    但在ConcurrentLinkedQueue中，head/tail的更新可能落后于节点的入队和出队，因为它不是直接对head/tail执行进行CAS操作，而是对Node中的item进行操作
                初始化
                    初始时，head和tail都指向一个null节点
                入队列
                    即使tail没有移动，只要对p的next指针成功进行CAS操作，就算成功入队
                    只有当p!=tail时，才会后移tail指针，即每连续追加2个节点，才后移一次tail指针，即使CAS失败也没关系，可以由下一个线程来移动tail指针
                出队列
                    出队的判断并非观察tail指针的位置，而是依赖于head指针后续的节点是否为NULL这一条件
                    只要对节点的item执行CAS操作，置为NULL成功，则出队成功，即使head指针没有成功移动，也可以由下一个线程继续完成
                队列为空
                    因为head/tail并不是精确地指向队列头部和尾部，所以不能简单地通过比较head/tail指针来判断队列是否为空
                    而是需要从head指针开始遍历，找第一个不为NULL的节点，如果找到，则队列不为空，如果找不到，则队列为空
            ConcurrentHashMap
                原理
                    HashMap通常实现方式是“数组+链表”，这个方式被称为“拉链法”，ConcurrentHashMap在这个基本原理上进行了各种优化
                    首先是所有数据都放在一个大的HashMap中，其次是引入了红黑树
                    如果头节点是Node类型，则尾随它的就是一个普通链表，如果头节点是一个TreeNode，则后面就是一个红黑树
                    链表和红黑树之间可以相互转换，初始时是链表，当链表元素超过某个阈值，把链表转换为红黑树，反之，当红黑树元素少于某个阈值，再转换为链表
                设计原理
                    使用红黑树，当一个槽里有很多元素时，其查询和更新速度会比链表快很多，Hash冲突能得到很好的解决
                    加锁的粒度，并非整个ConcurrentHashMap，而是对每个头节点分别加锁，即并发度就是Node数组的长度（初始为16）
                    并发扩容
                构造方法
                    cap（Node数组长度）保持为2的整数次方
                    tableSizeFor()根据传入的初始容量，计算出一个合适的数组长度
                    sizeCtl，用于控制再初始化或并发扩容时的线程数，默认初始值为cap
                初始化
                    构造方法中没有对数组进行初始化，当多个线程都往里面放入元素时，在进行初始化
                    多个线程的竞争通过对sizeCtl进行CAS操作实现，如果某个线程成功把sizeCtl设置为-1，它就拥有了初始化的权利，初始化完成，再将sizeCtl设置回去，其他线程一直执行while循环，自旋等待，直到数组不为null
                    初始化成功后，sizeCtl不再等于数组长度，而是n-(n&gt;&gt;&gt;2)=0.75n，表示下一次扩容的阈值
                put()实现
                    for循环分支
                        1、整个数组的初始化
                        2、所在槽为空，说明该元素是该槽的第一个元素，直接新建一个头节点，然后返回
                        3、该槽正在进行扩容，帮助其扩容
                        4、把元素放入槽内，槽内可能是链表/红黑树
                            包裹再synchronized(f)内，f对应的数组下标位置的头节点，意味着每个数组元素有一把锁，并发度等于数组长度
                扩容
                    MIN_TREEIFY_CAPCITY=64
                        意味着当数组长度没有超过64是，数组每个节点都是链表，只会扩容，不会转换为红黑树
                        当数组长度大于等于64时，才考虑把链表转换为红黑树
                    transfer()
                        基本原理
                            首先建一个新的HashMap，其长度是旧数组的2倍，然后把旧元素逐个迁移过来
                            方法有两个参数：1是tab扩容前的HashMap，2是nextTab扩容后的HashMap
                            该方法会被多个线程调用，所以每个线程只是扩容旧的HashMap部分，这就涉及如何划分任务的问题
                        并行扩容任务划分
                            旧数组长度是N，每个线程扩容一段，一段的长度用变量stride表示，transferIndex表示整个数组扩容的进度
                            stride在单核模式下直接等于n，因为没有办法多个线程并行扩容，多核模式下为(n&gt;&gt;&gt;3)/NCPU，且保证最小值为16，需要线程个数约为n/stride
                            transferIndex是一个成员变量，初始值为n，从大到小扩容，每次减stride个位置，最终减至n&lt;=0，表示整个扩容完成
                            transferIndex会被多个线程并发修改，因此需要通过CAS进行操作
                        扩容期间
                            扩容未完成前，有的数组下标对应的槽已经迁移到新数组，此时所有线程还是会访问旧HashMap
                            为此，当Node[0]迁移成功，会新建一个ForwardingNode，即转发节点，内部记录新的ConcurrentHashMap的引用，线程访问到ForwardingNode之后，会去查询新的HashMap
                        迁移
                            因为数组长度为2的整数次方，每次扩容又是2倍，则意味着处于第i个位置的元素，扩容后一定处于第i或i+n个位置
                    tryPresize()
                        输入是整个Hash表的元素个数，在函数里面，根据需要对整个Hash表进行扩容
                        它的核心是调用transfer函数
                        第一次扩容时，sizeCtl会被设置成一个很大的负数U.compareAndSwapInt(this,SIZECTL,sc,(rs&lt;&lt;RESIZE_STAMP_SHIFT)+2)
                        之后每一个线程扩容，sizeCtl就+1，待扩容完成后，sizeCtl-1
            ConcurrentSkipListMap/Set
                说明
                    ConcurrentHashMap是一种key无序的HashMap，而ConcurrentSkipListMap则是Key有序的，实现了NavigableMap接口
                ConcurrentSkipListMap
                    无锁链表
                        无锁队列、栈都是只在队头、队尾进行CAS操作，通常不会有问题，如果在链表的中间进行插入或删除，按照通常的CAS做法，就会出现问题
                    跳查表
                        解决了无锁链表的插入和删除问题，也就解决了跳查表的一个关键问题，因为跳查表就是多层链表叠起来的
                        put
                            在通过findPredecessor()找到待插入的元素在[b,n]之间后，并不能马上插入，因为其他线程也在操作这个链表，b、n都有可能被删除，所有在插入之前执行了一系列的检查逻辑，这也正是无锁链表的复杂之处
                ConcurrentSkipListSet
                    只是对ConcurrentSkipListMap的简单封装
            多线程集合容器
                ConcurrentHashMap
                    segment（jdk1.7）
                        08.144-concurrenthashmap-错误用法
                        08.145-concurrenthashmap-computeifabsent
                        08.146-concurrenthashmap-原理-hashmap-回顾
                        08.147-concurrenthashmap-原理-hashmap-死链
                        08.148-concurrenthashmap-原理-hashmap-死链
                        08.149-concurrenthashmap-原理-hashmap-死链
                        08.150-concurrenthashmap-8-原理-属性&内部类&方法
                        08.151-concurrenthashmap-8-原理-构造
                        08.152-concurrenthashmap-8-原理-get
                        08.153-concurrenthashmap-8-原理-put
                        08.154-concurrenthashmap-8-原理-put
                        08.155-concurrenthashmap-8-原理-initable
                        08.156-concurrenthashmap-8-原理-addcount
                        08.157-concurrenthashmap-8-原理-size
                        08.158-concurrenthashmap-8-原理-transfer
                        08.159-concurrenthashmap-7-原理-结构
                        08.160-concurrenthashmap-7-原理-定位segment
                        08.161-concurrenthashmap-7-原理-put
                        08.162-concurrenthashmap-7-原理-rehash
                        08.163-concurrenthashmap-7-原理-rehash补充
                        08.164-concurrenthashmap-7-原理-get
                        08.165-concurrenthashmap-7-原理-size
                    CAS+synchronize（jdk1.8）
                linkedblockingqueue
                    08.166-linkedblockingqueue-原理-入队出队
                    08.167-linkedblockingqueue-原理-安全分析
                    08.168-linkedblockingqueue-原理-put
                    08.169-linkedblockingqueue-原理-vs array
                Vertor
                ConcurrentHashMap
                    散列链表+红黑树
                    利用volatile+CAS实现
                    内部类TreeBin
                ConcurrentSkipListMap
                    跳表，按照key自然排序
                    利用volatile+CAS实现
                CopyOnWriteArrayList
                    数组
                    利用写时复制实现线程安全
                        volatile+ReentrantLock
                ConCurrentLinkedQueue
                    链表
                    利用volatile+CAS
        同步工具类
            Semaphore
                说明
                    即信号量，提供了资源数量的并发访问控制
                原理
                    实现原理和锁基本相同，资源总数即state的初始值，在acquire里对state变量进行CAS减操作，减到0之后，线程阻塞，在release里对state变量进行CAS加操作
                方法
                    acquire()
                        工作线程每获取一份资源，就在该对象上记下来
                    release()
                        工作线程每归还一份资源，就在该对象上记下来
                        此时资源可以被其他线程使用
            CountDownLatch
                等待都执行完 再执行
                await()
                    调用的是AQS的模板方法，只要state!=0，调用await()的线程便会被放入AQS的阻塞队列，进入阻塞状态
                countDown()
                    调用AQS的模板方法releaseShared()，只有state=0，才会返回true，然后一次性唤醒队列中所有阻塞的线程
                总结
                    由于是基于AQS阻塞队列来实现，所以可以让多个线程都阻塞在state=0条件上，通过countDown()一直减state，减到0后一次性唤醒多个线程
            CyclicBarrier
                使用场景
                    用于协调多个线程同步执行操作的场合
                实现原理
                    基于ReentrantLock+Condition实现
                说明
                    CyclicBarrier是可以被重用的，每一轮被称为一个Generation，即一次同步点
                    CyclicBarrier会响应中断，当线程没有到齐，如果有线程收到中断信号，所有阻塞的线程也会被唤醒，然后count被重置为初始值，重新开始
            Exchanger
                使用场景
                    用于线程之间交换数据
                实现原理
                    核心机制和Lock一样，也是CAS+park/unpark
                    Exchanger内部有两个内部类：Paritcipant、Node
                    每个线程调用exchange()交换数据时，会先创建一个Node对象
                        该对象就是对该线程的包装，包含了3个重要字段
                            该线程要交互的数据
                            对方线程交换来的数据
                            该线程自身
                    一个Node只能支持2个线程之间交换数据，要实现多个线程并行地交换数据，需要多个Node，因此Exchanger里定义了Node数组
                exchange(V x)
            Phaser
                说明
                    从JDK7开始，新增了一个同步工具类Phaser，其功能比CyclicBarrier和CountDownLatch更加强大
                    Phaser没有基于AQS来实现，但具备AQS的核心特性：state变量、CAS操作、阻塞队列
                新特性
                    1、动态调整线程个数
                        CyclicBarrier所要同步的线程个数是在构造方法中指定的，之后不能更改，而Phaser可以在运行期间动态地调整要同步的线程个数
                            register()
                                注册一个
                            bulkRegister()
                                注册多个
                            arriveAndDeregister()
                                解除注册
                    2、层次Phaser
                        多个Phaser可以组成树状结构，可以通过在构造方法中传入父Phaser来实现
                        Phaser内部结构中，每个Phaser记录了自己的父节点，但并没有记录自己的子节点列表
                            每个Phaser知道自己的父节点，但不知道自己有多少个子节点，对父节点的操作，是通过子节点来实现的
                        对于树状Phaser上的每个节点来说，可以当作一个独立的Phaser来看待，其运作机制和一个单独的Phaser一样
                        父Phaser并不用感知子Phaser的存在，当子Phaser中注册的参与者数量大于0，会把自己向父节点注册，当子Phaser中注册的参与者数量等于0，会自动向父节点解除注册
                        父Phaser把子Phaser当作一个正常参与的线程即可
                state变量
                    分为4部分
                        1位：是否完成同步，0/1，默认为0
                        31位：轮数
                        16位：总线程数
                        16位：未到达线程数
                    Phaser提供了一系列成员方法来从state中获取state的不同部分
                阻塞和唤醒
                    基于state变量，对其执行CAS操作，并进行相应的阻塞和唤醒
                        主线程会调用awaitAdvance()进行阻塞，工作线程调用arrive()对state进行CAS的累减操作，当未到达线程数减到0，唤醒阻塞的主线程
                    阻塞使用的是一个称为Treiber_Stack的数据结构，而不是AQS双向链表
                        Treiber_Stack是一个无锁的栈，它是一个单向链表，出栈入栈都在链表头部，所以只需要一个head指针，而不需要tail指针
                    为了减少并发冲突，定义了两个Treiber_Stack，当phase为奇数轮时，阻塞线程放在oddQ中，当phase为偶数轮时，阻塞线程放在evenQ中
                arrive()
                    arrive()和arriveAndDeregister()内部都是调用doArrive(boolean)，区别在于前者只是把“未到达线程数”减1，后者则把“未到达线程数”和“下一轮总线程数”都减1
                awaitAdvance()
        aqs构建的同步器
            独占式
                ReentrantLock
                    ReentrantLock 和 ReentrantRead
            共享式
                Semaphore信号量：多线程访问
                    acquire（）
                    acquierUninterruptibly（）
                    tryAcquire（）
                    release（）
                CountDownLatch清空唤醒
                    jdk1.5引入
                    内部维护计数器
                    await（）
                        被await（）阻塞的线程，等待countdownlatch计数器清零后继续执行
                    countDow()
                        使计数器减一，报告自己已完成任务
                    CountDownLatch （倒计时器）
                    CountDownLatch 的两种典型用法
                    CountDownLatch 的使用示例
                    CountDownLatch 的不足
                    CountDownLatch 相常见面试题
            组合
                ReentrantReadWriteLock 
                    读写分离，读是共享，写是独占
            CyclicBarrier栅栏、
                CyclicBarrier(循环栅栏)
                CyclicBarrier 的应用场景
                CyclicBarrier 的使用示例
                CyclicBarrier 源码分析
                CyclicBarrier 和 CountDownLatch 的区别
                await()
        atomic包
            Atomic类
                AtomicInteger/AtomicLong
                    说明
                        对于一个整数的加减操作，要保证线程安全，需要加锁，即加synchronized
                        但有了Concurrent的Atomic相关类之后，synchronized可以用相关Atomic类代替，其性能更好
                    AtomicInteger
                        getAndIncrement()和getAndDecrement()都调用了U.getAndAddInt()，该方法基于CAS实现
                        getAndAddInt()具有volatile语义，即对所有线程都是同时可见的
                    悲观锁/乐观锁
                        对于悲观锁，认为数据发生并发冲突的概率很大，读操作之前就上锁，synchronized、ReentrantLock都是悲观锁的典型
                        对于乐观锁，认为数据发生并发冲突的概率较小，读之前不上锁，等到写操作时，再判断数据在此期间是否被其他线程修改了
                            如果修改了，就把数据重新读出来，重复该过程
                            如果没修改，就写回去
                            判断数据是否被修改，同时写回新值，这两个操作要合成一个原子操作，即CAS（CompareAndSet）
                        AtomiInteger的实现就是典型的乐观锁
                    Unsafe的CAS
                        Unsafe类是整个Concurrent包的基础，里面所有方法都是native的
                        compareAndSetInt(Object, long, int, int)
                            第二个参数是long型，经常被称为xxxOffset，表示某个成员变量在对应的类中的内存偏移量（该变量在内存中的位置），表示该成员变量本身
                        所有调用CAS的地方，都会先通过objectFieldOffset1()把成员变量转换成一个Offset
                    自旋/阻塞
                        当一个线程拿不到锁时，有两种基本的等待策略
                            1、放弃CPU，进入阻塞状态，等待后续被唤醒，再重新被操作系统调度
                            2、不放弃CPU，空转，不断重试，即所谓的“自旋”
                        对于单核CPU，只能用策略1，而对于多核或多CPU，可以使用策略2，因为没有线程切换的开销
                        两种策略并不互斥，可以结合使用，如果获取不到锁，先自旋，如果还拿不到，再阻塞，synchronized关键字就是这样的实现策略
                        AtomicInteger的实现就用的是自旋策略，如果拿不到锁，就会一直重试
                AtomicBoolean/AtomicReference
                    为什么需要AtomicBoolean
                        因为往往需要实现先判断后赋值的操作，即两个操作合在一起的原子性，即CAS提供的功能
                    支持boolean/double
                        Unsafe类中，只提供了三种类型的CAS操作：int、long、Object（引用类型）
                        在JDK实现中，这三种CAS操作都是由底层实现的，其他类型的CAS操作都要转换为这三种之一进行操作
                        AtomicBoolean
                            用int来代替，入参时，将boolean转换为int，返回时，将int转换为boolean
                        double类型
                            依赖double类型提供的一对double类型核long类型互转的方法
                                longBitsToDouble()
                                doubleToRawLongBits()
                AtomicStampedReference/AtomicMarkableReference
                    ABA问题
                        CAS都是基于“值”来做比较的，如果另一个线程把变量从A改为B，再从B改为A，则尽管修改了两次，但在当前线程做CAS操作时，却会因为值没变而认为数据没有被其他线程修改过
                        要解决ABA问题，不仅要比较值，还要比较“版本号”，这正是AtomicStampedReference的事情
                    说明
                        compareAndSet
                            这里的CAS有4个参数，后两个参数就是版本号的旧值和新值
                        因为要同时比较数据的“值”和“版本号”，而Integer或Long类型的CAS没有办法同时比较两个变量，所以只能把值和版本号封装成一个对象（Pair内部类），然后通过对象引用的CAS来实现
                    AtomicMarkableReference
                        原理与AtomicStampedReference类似，只是Pair里的版本号是boolean类型，而不是整型的累积变量
                        因为是boolean类型，只能有true、false两个版本号，所以并不能完全避免ABA问题，只是降低了ABA发生的概率
                AtomicXXXFieldUpdater
                    说明
                        如果一个类是自己编写的，则可以在编写时把成员变量定义为Atomic类
                        但如果是一个已有的类，在不更改源码情况下，要实现对其成员变量的原子操作，就需要AtomicXXXFieldUpdater
                    原理
                        AtomicIntegerFieldUpdater为例，它是一个抽象类，构造方法是protected，不能直接构造其对象，必须通过它提供的一个静态方法来创建
                        newUpdater()
                            传入的是要修改的类（非对象）和对应的成员变量的名字，内部通过反射拿到这个类的成员变量，然后包装成一个AtomicIntegerFieldUpdater对象
                            所以这个对象表示的是类的某个成员，而不是对象的成员变量
                        若要修改某个对象的成员变量的值，再传入相应的对象
                            getAndIncrement(T obj)
                    限制条件
                        如果想使用AtomicXXXFieldUpdater修改成员变量，成员变量必须是volatile的int类型（不能是Integer包装类）
                AtomicXXXArray
                    说明
                        Concurrent包提供了AtomicXXXArray（Integer、Long、Reference）三个数组元素的原子操作
                            并不是对整个数组的操作，而是针对数组中某个元素的原子操作
                    使用方式
                        相比对应的AtomicXXX，各类操作方法中多了一个传入参数：数组的下标（i）
                    实现原理
                        其底层的CAS方法直接调用VarHandle中native的getAndAdd()
                Striped64/LongAdder
                    说明
                        从JDK8开始，针对Long型的原子操作，又提供了LongAdder、LongAccumulator
                        针对Double型，提供了DoubleAdder、DoubleAccumulator
                    LongAdder原理
                        AtomicLong内部是一个volatile_long型变量，由多个线程对这个变量进行CAS操作，然而在高并发下仍不够快，需要再提高性能
                        把一个变量拆成多份，变为多个变量，类似于ConcurrentHashMap的分段锁
                        把一个Long型拆成一个base变量外加多个Cell，每个Cell包装一个Long型变量
                            当多个线程并发累加时，如果并发度低，就直接加到base变量上
                            如果并发度高，冲突大，平摊到Cell上，最后取值时，再把base和Cell求sum运算
                        由于无论是long，还是double都是64位的，但因为没有double的CAS操作，所以通过把double转化成long来实现
                    最终一致性
                        在最终求和时，并没有对Cells数组加锁，即线程对其执行求和和修改可能是并行的，即最终一致性，而不是强一致性
                        因此，LongAdder适合高并发的统计场景，而不适合要对某个Long型变量进行严格同步的场景
                    伪共享和缓存行填充
                        Cell类定义中，用了一个独特的注解@sum.misc.Contended
                            这是JDK8之后有的，涉及了一个很重要的优化原理：伪共享和缓存行填充
                        每个CPU都有自己的缓存，缓存与主内存进行数据交换的基本单位叫CacheLine（缓存行）
                            在64位x86架构中，缓存行是64字节，即8个Long型大小，即意味着当缓存失效，要刷新到主内存时，最少要刷新64字节
                        伪共享
                            假设主内存中有变量X、Y、Z（均为Long型），被CPU1、CPU2分别读入自己的缓存，放在同一行的CacheLine中
                            当CPU1修改了X，它要失效整行CacheLine，即往总线上发消息，通知CPU2对应的CacheLine失效
                            由于CacheLine是数据交换的基本单位，失效X会导致失效整行CacheLine，即失效Y、Z缓存
                        解决
                            需要用到所谓的“缓存行填充”，分别在X、Y、Z后面填充7个无用的Long型，填充整个缓存行，使X、Y、Z处于不同的缓存行
                        声明@jdk.internal.vm.annotation.Contended即可实现缓存行填充，之所以这里要用缓存行填充，使为了不让Cell数组中相邻的元素落到同一个缓存行中
                    核心实现
                        LongAdder最核心的累加方法add(long)，自增、自减操作都是通过调用该方法实现
                        当一个线程调用add()时，首先会尝试使用casBase把x加到base变量上，如果不成功，则使用c.cas()尝试把x加到Cell数组的某个元素上，如果还不成功，则调用longAccumulate()
                        Cells数组的大小始终是2的整数次方，在运行中不断扩容，每次扩容增长为2倍
                        对于一个线程来说，它并不在意到底是把x累加到base上，还是累加到Cells数组上，只要累加成功即可，因此，使用随机数来实现Cell的长度取模
                    LongAccumulator
                        类似LongAdder，但功能更加强大
                            LongAdder只能进行累加操作，且初始值默认为0
                            LongAccumulator可以自定义一个二元操作符，且可以传入一个初始值
                        LongBinaryOperator
                            二元操作符
                    DoubleAdder/DoubleAccumulator
                        其实也是long型实现，因为没有double类型的CAS方法
    juc的实现原理
        AQS:AbstractQueuedSynchronizer抽象队列同步器
            AQS 对资源的共享方式：如上
            AQS 底层使用了模板方法模式
被await（）阻塞的线程，等待countdownlatch计数器清零后继续执行
使计数器减一，报告自己已完成任务