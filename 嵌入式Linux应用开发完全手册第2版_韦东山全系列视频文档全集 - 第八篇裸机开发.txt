第八篇 裸机开发	604
	第一章  硬件资源	604
		1.1 板上资源	604
		1.2 板外模块	605
	第二章  准备开发环境	606
		🤮1.3 100ASK_IMX6ULL开发板接线与启动	606
			a.串口线
			b.安装usb驱动
			c.选择启动方式
			b.设置串口工具，启动开发板
		🤮1.4 安装SDK、设置工具链	609
			a.交叉编译工具
			b.vmware ubuntu镜像
			c.vmware上网
			d.配置交叉编译工具
		🤮1.5 裸机源码	609
		🤮1.6 BSP包和烧写工具	609
			a.烧写工具，SD卡
			b.芯片手册 :查找对应的寄存器
			c.原理图

	第三章  IMX6ULL启动流程	610
		1.1 IMX6ULL启动方式	610
			1.1.1 芯片手册讲解	610
				烧写方式：
					USB
					串口
					MMC
					FLash
			1.1.2 100ASK_IMX6ULL启动方式选择	613
				EMMC启动：生产时使用
				SD卡启动：
				USB烧写：不能插上SD，TF
			1.1.3 GPIO boot overrides	614
		1.2 IMX6ULL启动流程	615
			a. 检查 CPU ID
			b. 检查 Reset Type，冷启动、唤醒的启动过程是不一样的
			c. 检查启动模式 BOOT_MODE，检查 eFUSE 或 GPIO
			d. 根据上述检查从 USB 口、UART 口或是某个启动设备下载 boot image
			e. 认证 image
			f. 启动
		1.3 IMX6ULL映像文件	616
			1.3.1 格式概述	616
				image vector table 镜像描述表
				boot data 启动数据的地址
				self 映像复制IVT，bootdata地址
				DCD 设备配置数据
			1.3.2 格式详解	617
			1.3.3 实例	621
		🤮1.4 映像文件烧写、运行	623
			1.4.1 使用USB运行裸机程序	624
				a,开发板设置usb启动
				b,usb连接电脑和开发板OTG
				c，运行烧写工具
			1.4.2 使用读卡器烧写裸机程序到SD/TF卡	625
				a.烧写TF卡
				b.启动开发板
			1.4.3 使用USB烧写裸机程序到SD/TF	626
				a，开发板设置为USB启动
				b，使用usb线连接电脑和开发板的OTG口
				c，烧写工具选择烧写到SD/TF
			1.4.4 使用USB烧写裸机程序到EMMC	627
			1.4.5 VMWARE可能会截取USB设备导致烧写失败	628
			1.4.6 USB下载时驱动无法安装	628
	第四章  LED程序	629
		1.1 硬件知识_LED原理图	629
		1.2 普适的GPIO引脚操作方法	630
			1.2.1 GPIO模块一般结构	630
			1.2.2 GPIO寄存器操作	631
			1.2.3 GPIO的其他功能：防抖动、中断、唤醒	631
		1.3 IMX6ULL的GPIO操作方法	632
			1.3.1 IMX6ULL的GPIO模块结构	632
			1.3.2 CCM用于设置是否向GPIO模块提供时钟	633
			1.3.3 IOMUXC：引脚的模式(Mode、功能)	634
			1.3.4 GPIO模块内部	637
			1.3.5 怎么编程	638
		1.4 100ASK_IMX6ULL的LED程序	639
			1.4.1 看原理图确定引脚及操作方法	639
			1.4.2 所涉及的寄存器操作	639
			1.4.3 写程序	642
			1.4.4 编译程序	644
			1.4.5 上机实验	644
	第五章  LED程序涉及的编程知识	645
		1.1 ARM处理器程序运行的过程	645
		1.2 ARM架构的简单介绍	646
			1.2.1 运行模式	646
			1.2.2 寄存器组	647
				① 未备份寄存器	648
				② 备份寄存器	648
				③ 程序计数器	648
				④ 程序状态寄存器	648
		1.3 汇编与机器码、汇编指令	650
			1.3.1 汇编与机器码	650
			1.3.2 汇编指令	651
				MOV指令	652
				BL指令	652
				B指令	653
				ADD/SUB指令	654
				LDR/STR指令	654
				LDR伪指令	656
				LDM/STM指令	656
		1.4 进制	658
			1.4.1 如何理解它们的区别？	658
			1.4.2 在C语言中怎么表示这些进制呢？	658
			1.4.3 十六进制与二进制转换关系	659
		1.5 大/小端模式与位操作	659
			1.5.1 大/小端模式	659
			1.5.2 位操作	660
				移位	660
				取反	660
				位与	660
				位或	660
				置位	660
				清位	660
		1.6 汇编程序调用C程序	661
			1.6.1 ATPCS规则	661
			1.6.2 汇编程序如何向C程序的函数传递参数	661
			1.6.3 C程序如何返回结果给汇编程序	661
			1.6.4 C函数为何要用栈	661
		1.7 C语言中读写寄存器	662
		1.8 start.S解析	662
		1.9 根据led.dis分析代码的整体运行流程	664
	第六章  Makefile与GCC	668
		1.1 交叉编译器	668
			1.1.1 什么是交叉编译	668
			1.1.2 验证实例	669
		1.2 GCC常用选项及编译过程详解	670
			1.2.1 gcc编译过程详解	670
				预处理：	670
				编译：	670
				汇编：	670
				链接：	670
			1.2.2 gcc命令	671
				过程控制选项	671
				输出选项	673
				头文件选项	674
				链接库选项	674
				代码优化选项	675
				调试选项及调试示例	675
					GDB
			1.2.3 编译错误警告	677
		1.3 深入讲解GCC链接过程	678
			1.3.1 动态链接库和静态链接库使用例程	679
				静态库链接	680
				动态库链接	680
		1.4 Makefile的引入及规则	681
			1.4.1 为什么需要Makefile?	681
			1.4.2 Makefile的引入	681
			1.4.3 Makefile的规则	684
				命名规则：	684
				基本语法规则：	684
				目标生成规则：	684
		1.5 Makefile的语法	686
			1.5.1 变量的定义及取值	686
				赋值符‘=’	687
				赋值符‘:=’	687
				赋值符‘?=’	688
				赋值符‘+=’	688
			1.5.2 系统自带变量	689
			1.5.3 自动变量	689
			1.5.4 模式规则	690
			1.5.5 伪目标	690
			1.5.6 Makefile函数	692
				wildcard函数	692
				patsubst函数	692
				字符串替换和分析函数	693
				文件名函数	694
				其他函数	695
		🤮1.6 Makefile实例	697
			1.所有的头文件放到inc文件夹中
			2.在最终的可执行文件添加版本号

	第七章  时钟体系	700
		1.1 IMX6ULL时钟体系介绍	700
			1.1.1 晶体振荡电路	700
			1.1.2 锁相环电路	701
			1.1.3 根时钟信号电路	704
		1.2 寄存器介绍	706
			1.2.1 锁相环电路寄存器	708
			1.2.2 根时钟控制寄存器	710
			1.2.3 模块时钟屏蔽寄存器	711
		1.3 编程示例	712
			1.3.1 改变CPU工作频率	712
				设置PLL1_SW_CLK的时钟路径	712
				重新设置ARM_PLL的输出频率	713
				设置ARM_CLK_ROOT的分频参数	715
				修改led闪烁函数	715
				参考章节《4-1.4.4编译程序》编译程序	716
				参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	716
			1.3.2 打印时钟信号的频率值	717
				获取PLL的输出频率	717
				获取PLL1_SW_CLK的时钟频率	721
				获取PLL1_SW_CLK的时钟频率	723
				函数打印时钟值	728
				参考章节《4-1.4.4编译程序》编译程序	729
				参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	729
			1.3.3 补充说明	730
	第八章  UART串口编程	731
		1.1 UART介绍	731
			1.1.1 UART串口简介	731
			1.1.2 UART硬件连接	731
			1.1.3 UART通讯数据格式	733
		1.2 IMX6ULL UART寄存器介绍	734
			1.2.1 IMX6ULL UART模块简介	734
			1.2.2 IMX6ULL UART寄存器简介	734
				UART1_URXD	735
				UART1_UTXD	735
				UART1_UCR1	735
				UART1_UCR2	736
				UART1_UCR3	736
				UART1_UFCR	736
				UART1_USR2	736
				UART1_UBIR与UART1_UBMR	736
		1.3 IMX6ULL UART编程	737
			1.3.1 看原理图确定UART引脚	737
			1.3.2 涉及的UART1寄存器配置	737
				步骤1：配置并使能UART1时钟	737
				步骤2：复用相关GPIO为UART1功能	739
				步骤3：设置UART1传输格式，波特率	740
				步骤4：使能UART1	744
			1.3.3 实现串口发送功能	744
				步骤1： 编写UART1发送单字节函数	744
				步骤2：编写用于测试的main函数	745
				步骤3：参考章节《4-1.4.4编译程序》编译程序	745
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	745
			1.3.4 实现串口接收功能	746
				步骤1：编写UART1接收单字节函数	746
				步骤2：编写用于测试main函数	746
			1.3.5 完善回显功能	747
			1.3.6 实现串口发送字符串功能	748
				步骤1：实现打印字符串函数	748
				步骤2：在main函数中添加打印字符串函数的调用	748
				步骤3：参考章节《4-1.4.4编译程序》编译程序	748
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	748
		1.4 移植printf	748
			1.4.1 在上一个程序的基础上移植	748
			1.4.2 变参数函数移植	749
			1.4.3 编写my_vprintf(fmt, ap)	750
			1.4.4 编写out_c，outs与out_num函数	751
			1.4.5 编写my_printf_test的测试函数	752
			1.4.6 编写main测试程序	753
				步骤1：参考章节《4-1.4.4编译程序》编译程序	753
				步骤2：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	753
	第九章  重定位	754
		1.1 段的概念	754
			1.1.1 步骤1：在主函数文件中创建不同属性的全局变量	754
			1.1.2 步骤2：创建链接脚本	754
			1.1.3 步骤3：在Makefile文件中指明使用链接脚本imx6ull.lds控制链接过程	755
			1.1.4 步骤4：参考章节《4-1.4-1.4.4 编译程序》编译程序并查看反汇编文件relocate.dis	755
		1.2 链接脚本解析	757
			1.2.1 链接脚本语法	757
			1.2.2 解析链接脚本	758
			1.2.3 清除bss段	759
				步骤1：修改汇编文件	759
				步骤2：在主函数汇中添加测试代码	760
				步骤3：参考章节《4-1.4.4编译程序》编译程序	761
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	761
		1.3 重定位的引入	761
			1.3.1 什么是重定位	761
			1.3.2 汇编重定位data段	761
				步骤1：参考章节《4-1.4.4编译程序》编译程序	762
				步骤2：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	762
				步骤1：参考芯片手册确定片内RAM的位置	762
				步骤2：修改链接脚本	762
				步骤3：修改汇编文件重定位.data段	764
				步骤3：参考章节《4-1.4.4编译程序》编译程序	765
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	765
		1.4 C函数重定位data段和清除bss段	765
			1.4.1 通过汇编传递链接脚本变量	765
				步骤1：修改汇编文件	765
				步骤2：创建程序文件init.c实现copy_data, clean_bss函数	766
				步骤3：修改Makefile	767
				步骤3：参考章节《4-1.4.4编译程序》编译程序	767
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	767
			1.4.2 C函数直接调取链接脚本变量	767
				步骤1：修改汇编文件，改为直接调用C函数	768
				步骤2：修改init.c 通过函数来获取参数	768
				步骤3：参考章节《4-1.4.4编译程序》编译程序	769
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	769
			1.4.3 总结:如何在C函数中使用链接脚本变量	770
		1.5 重定位全部代码	771
			1.5.1 C函数实现重定位全部代码	771
				步骤1：修改链接脚本	771
				步骤2：修改init.c	772
				步骤3：修改汇编文件	772
				步骤3：参考章节《4-1.4.4编译程序》编译程序	772
				步骤4：参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	772
			1.5.2 位置无关码	773
	第十章  异常与中断	775
		1.1 异常与中断的引入	775
			1.1.1 妈妈怎么知道孩子醒了	775
			1.1.2 嵌入系统中也有类似的情况	776
		1.2 异常与中断的处理流程	777
		1.3 怎么保存现场：栈	778
			1.3.1 ARM处理器程序运行的过程	778
			1.3.2 程序被中断时，怎么保存现场	779
		1.4 ARM处理器模式和寄存器	780
			1.4.1 寄存器	781
			1.4.2 状态寄存器	782
			1.4.3 协处理器CP15	783
				System control register (SCTLR)	783
		1.5 异常处理	784
			1.5.1 异常的类型	784
			1.5.2 异常优先级	786
			1.5.3 向量表	787
			1.5.4 FIQ and IRQ	787
			1.5.5 返回指令	787
			1.5.6 异常处理	788
				从异常处理程序返回	788
			1.5.7 中止(ABT)处理程序	789
			1.5.8 未定义的指令处理	789
			1.5.9 SVC异常处理	789
		1.6 und异常模示程序示例	790
			1.6.1 代码分析	790
			1.6.2 参考章节《4-1.4.4编译程序》编译程序	792
			1.6.3 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	792
		1.7 SVC异常模示程序示例	793
			1.7.1 代码分析	793
			1.7.2 参考章节《4-1.4.4编译程序》编译程序	796
			1.7.3 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	796
		1.8 中断处理	796
			1.8.1  外部中断请求	796
			1.8.2 分配中断	797
			1.8.3 简单的中断处理	797
			1.8.4 嵌套中断处理	798
		1.9 通用中断控制器（GIC, Generic Interrupt Controller）	798
			1.9.1 配置	800
			1.9.2 初始化	800
			1.9.3 GIC中断处理	801
		1.10 中断控制器寄存器	802
			1.10.1  Distributor 寄存器描述	802
				Distributor Control Register, GICD_CTLR	802
				Interrupt Controller Type Register, GICD_TYPER	802
				Distributor Implementer Identification Register, GICD_IIDR	803
				Interrupt Group Registers, GICD_IGROUPRn	803
				Interrupt Set-Enable Registers, GICD_ISENABLERn	804
				Interrupt Clear-Enable Registers, GICD_ICENABLERn	804
				Interrupt Set-Active Registers, GICD_ISACTIVERn	805
				Interrupt Clear-Active Registers, GICD_ICACTIVERn	805
				Interrupt Priority Registers, GICD_IPRIORITYRn	806
				Interrupt Processor Targets Registers, GICD_ITARGETSRn	806
				Interrupt Configuration Registers, GICD_ICFGRn	807
				Identification registers: Peripheral ID2 Register, ICPIDR2	807
			1.10.2 CPU interface寄存器描述	808
				CPU Interface Control Register, GICC_CTLR	808
				Interrupt Priority Mask Register, GICC_PMR	809
				Binary Point Register, GICC_BPR	809
				Interrupt Acknowledge Register, GICC_IAR	809
				Interrupt Register, GICC_EOIR	810
	第十一章  GPIO中断	811
		1.1  GPIO中断介绍(通用的概念)	811
			1.1.1 GPIO中断	812
			1.1.2 IMX6ULL GIC中断控制器功能概述	813
			1.1.3 IMX6ULL GIC中断寄存器	816
				GICC_IAR寄存器	816
				GICC_EOIR寄存器	816
			1.1.4 CP15协处理器	817
				CP15协处理器介绍	817
				SCTLR（System Control Register）寄存器	817
				VBAR（Vector Base Address）寄存器	820
		1.2 IMX6ULL的GPIO中断寄存器介绍	820
			1.2.1 GPIO interrupt configuration register1 (GPIOx_ICR1)	820
			1.2.2 GPIO interrupt configuration register2 (GPIOx_ICR2)	821
			1.2.3 GPIO interrupt mask register (GPIOx_IMR)	821
			1.2.4 GPIO interrupt status register (GPIOx_ISR)	821
			1.2.5 GPIO edge select register (GPIOx_EDGE_SEL)	822
		1.3 按键中断程序编程示例	822
			1.3.1 管脚设置和查询中断号	822
			1.3.2 GIC控制器基地址的获取方法	823
			1.3.3 GIC的初始化	823
			1.3.4 中断异常处理汇编部分	824
			1.3.5 中断异常处理C函数部分	827
			1.3.6 GPIO中断初始化和安装中断处理程序	827
			1.3.7 特定中断号的中断使能和禁止	829
			1.3.8 修改CPSR使能中断	830
			1.3.9 主函数调用	830
			1.3.10 参考章节《4-1.4.4编译程序》编译程序	831
			1.3.11 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	831
	第十二章  GTP定时器和EPIT定时器编程	832
		1.1 GPT定时器介绍	832
			1.1.1 时钟源选择	833
			1.1.2 时钟源选择的操作流程	834
			1.1.3 GPT的计数模式	835
			1.1.4 GPT的操作	835
			1.1.5 GPT的输入捕获	836
			1.1.6 GPT的输出比较	836
			1.1.7 GPT的中断	837
		1.2 GPT寄存器介绍	838
			1.2.1 GPT Control Register (GPTx_CR)	838
			1.2.2 GPT Prescaler Register (GPTx_PR)	839
			1.2.3 GPT Status Register (GPTx_SR)	840
			1.2.4 GPT Interrupt Register (GPTx_IR)	840
			1.2.5 GPT Output Compare Register 1~3 (GPTx_OCR1~3)	841
			1.2.6 GPT Input Capture Register 1~2 (GPTx_ICR1~2)	841
			1.2.7 GPT Counter Register (GPTx_CNT)	841
		1.3 GPT查询方式延时代码详解与测试	842
			1.3.1 代码分析	842
			1.3.2 参考章节《4-1.4.4编译程序》编译程序	844
			1.3.3 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	844
		1.4 GPT中断方式延时代码详解与测试	845
			1.4.1 GPT1中断号的确定	845
			1.4.2 代码分析	845
				通过gpt_init函数初始化gpt	845
				gpt中断使能函数	846
				启动GPT函数	846
				中断处理函数	846
				主函数的设置	847
			1.4.3 参考章节《4-1.4.4编译程序》编译程序	847
			1.4.4 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	847
		1.5 EPIT定时器介绍	848
			1.5.1 EPIT特性	848
			1.5.2 操作模式	848
			1.5.3 操作过程	849
			1.5.4 比较事件	850
		1.6 EPIT寄存器介绍	850
			1.6.1 Control register (EPITx_CR)	850
			1.6.2 Status register (EPITx_SR)	852
			1.6.3 Load register (EPITx_LR)	852
			1.6.4 Compare register (EPITx_CMPR)	852
			1.6.5 Counter register (EPITx_CNR)	853
		1.7 EPIT查询方式延时代码详解	853
			1.7.1 代码分析	853
				epit_poll_init函数	853
				epit_poll_restart函数	854
				epit_run函数	855
				主函数	855
			1.7.2 参考章节《4-1.4.4编译程序》编译程序	856
			1.7.3 参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	856
		1.8 EPIT中断实现延时代码详解	857
			1.8.1 EPIT1中断号的确定	857
			1.8.2 代码分析	857
				初始化EPIT1	857
				打开或者关闭比较中断	858
				EPIT运行使能函数	858
				中断处理函数	859
				主函数	859
				参考章节《4-1.4.4编译程序》编译程序	860
				参考章节《3-1.4映像文件烧写、运行》烧写、运行程序	860
	第十三章  EMMC编程	861
	第十四章  TF卡编程	861
	第十五章  LCD编程	862
		1.1 LCD硬件原理	862
			1.1.1 LCD硬件工作原理简介	862
			1.1.2 RGB接口的LCD硬件连接信号	864
			1.1.3 TFT材质液晶屏接口简介(7寸1024600TN-RGB)	866
			1.1.4 LCD关键特性	867
				行时序	867
				列时序	868
				DE模式	869
				RGB数据的存放形式	869
		1.2 IMX6ULL LCD控制器操作及寄存器	870
			1.2.1 LCD控制器模块介绍	870
			1.2.2 LCD控制器寄存器简介	871
				LCDIF_CTRL寄存器	872
				LCDIF_CTRL1寄存器	874
				LCDIF_TRANSFER_COUNT寄存器	874
				LCDIF_VDCTRL0寄存器	875
				LCDIF_VDCTRL1寄存器	876
				LCDIF_VDCTRL2寄存器	876
				LCDIF_VDCTRL3寄存器	876
				LCDIF_VDCTRL4寄存器	877
				LCDIF_CUR_BUF寄存器	877
				LCDIF_NEXT_BUF寄存器	877
		1.3 编程_框架与准备	878
			1.3.1 功能目的	878
			1.3.2 编程框架	878
		1.4 编程_抽象出重要结构体	879
			1.4.1 抽象出LCD屏幕的结构体	879
			1.4.2 抽象出LCD控制器的结构体	881
		1.5 编程_LCD控制器	882
			1.5.1 LCD控制器相关引脚复用配置	882
			1.5.2 LCD控制器像素时钟配置	883
				确定PLL	883
				确定PLL后的分频系数	883
				PLL分频后进入LCDIF控制器前的分频系数	884
			1.5.3 LCD控制器时钟编程	884
				取消小数分配器	884
				设置CCM_ANALOG_PLL_VIDEOn寄存器	884
				设置CCM_ANALOG_MISC2n	885
				设置CCM_CSCDR2	886
				设置CCM_CBCMR	886
				重新同步时钟	887
			1.5.4 LCD控制器像素格式配置	887
				设置LCDIF_CTRLn寄存器	888
				设置LCDIF_CTRL1n寄存器	889
			1.5.5 LCD控制器时序配置及极性配置	889
				设置LCDIF_TRANSFER_COUNT寄存器	889
				设置LCDIF_VDCTRL0n寄存器	890
				配置LCDIF_VDCTRL1寄存器	890
				配置LCDIF_VDCTRL2寄存器	891
				配置LCDIF_VDCTRL3寄存器	891
				设置LCDIF_VDCTRL4寄存器	891
			1.5.6 设置显存	892
		1.6 编程_LCD设置	892
			1.6.1 添加LCD屏幕名称	892
			1.6.2 极性设置	892
			1.6.3 时序设置	893
			1.6.4 显存地址设置	894
		1.7 编程_简单测试	895
			1.7.1 初始化LCD	895
			1.7.2 使能LCD	895
			1.7.3 获取LCD参数	896
			1.7.4 往framebuffer中写数据	896
		1.8 编程_画点线圆	898
			1.8.1 实现画点	898
			1.8.2 实现画线	899
			1.8.3 实现画圆	900
		1.9 编程_显示文字	901
			1.9.1 获取LCD参数	901
			1.9.2 编写单个字符显示函数	901
			1.9.3 编写实现字符串显示函数	902
	第十六章  I2C编程	904
		1.1 I2C协议	904
			1.1.1 概述	904
			1.1.2 物理层	906
				特性1：半双工（非全双工）	906
				特性2：地址和角色可配置	906
				特性3：多主机	906
				特性4：传输速率	906
				特性5：负载和距离	906
			1.1.3 协议层	907
				数据有效性	907
				起始和结束条件	907
				应答	907
				数据帧格式	907
		1.2 IMX6ULL的I2C控制器操作与寄存器介绍	908
			1.2.1 I2C Memory Map	909
			1.2.2 寄存器介绍	909
				I2C地址寄存器(I2Cx_IADR)	909
				I2C分频寄存器(I2Cx_IFDR)	910
				I2C控制寄存器(I2Cx_I2CR)	911
				I2C状态寄存器(I2Cx_I2SR)	912
				I2C数据寄存器(I2Cx_I2DR)	913
		1.3 AP3216C操作方法	914
			1.3.1 AP3216C简介	914
			1.3.2 AP3216C特性	914
			1.3.3 AP3216C结构图	915
			1.3.4 AP3216C寄存器	916
			1.3.5 AP3216C寄存器读写方法	916
		1.4 程序框架	918
		1.5 I2C控制器编程	918
			1.5.1 I2C读写标准流程	919
			1.5.2 重要的结构体	921
			1.5.3 i2c_init	922
			1.5.4 i2c_transfer	923
			1.5.5 i2c_start	927
			1.5.6 i2c_check	928
			1.5.7 i2c_write	929
			1.5.8 i2c_read	930
		1.6  AP3216C编程	931
			1.6.1 AP3216C初始化IO	931
			1.6.2 初始化AP3216C	932
			1.6.3 AP3216C数据读取	933
		1.7 AP3216C上机实验	934
			1.7.1 AP3216C实验一	935
			1.7.2 AP3216C实验二	936
	第十七章  多点触摸电容屏编程(I2C接口)	937
		1.1 电容屏协议介绍	937
		1.2 电容屏I2C操作方法	937
		1.3 编程	937
		1.4 上机实验	937
	第十八章  SPI编程	938
		1.1 SPI接口简介	938
			1.1.1 SPI硬件连接	938
			1.1.2 SPI通讯数据格式	938
		1.2 IMX6ULL的SPI控制器操作与寄存器介绍	940
			1.2.1 SPI控制器介绍	940
			1.2.2 SPI控制器初始化流程	941
			1.2.3 SPI控制器寄存器介绍	942
				ECSPIx_RXDATA	942
				ECSPIX_TXDATA	942
				ECSPIX_CONREG	943
				ECSPIX_CONFIGREG	944
				ECSPIX_STATREG	946
				ECSPIX_TESTREG	947
			1.2.4 SPI控制器引脚设置	947
				初始化SPI3引脚	948
				初始化SPI3工作速率	950
		1.3 ICM-20608-G操作方法	952
			1.3.1 ICM-20608-G介绍	952
			1.3.2 ICM-20608-G接口	953
			1.3.3 ICM-20608-G相关寄存器	954
			1.3.4 ICM-20608-G读写方法	956
		1.4 SPI控制器编程	957
			1.4.1 SPI控制器引脚设置	957
				设置引脚的工作模式	957
				引脚初始化代码	958
			1.4.2 SPI控制器时钟设置	958
				设置SPI时钟	959
				SPI时钟设置相关代码	960
			1.4.3 SPI控制器控制和配置	961
				步骤1_CONREG寄存器	961
				步骤2_CONFIGREG寄存器	962
			1.4.4 发送和接收数据	963
		1.5 ICM-20608-G编程	963
			1.5.1 ICM-20608-G配置初始化	963
				选择内部晶振作为时钟	963
				设置采样率	964
				配置寄存器	964
				角速度传感器设置	965
				加速度传感器设置1	965
				加速度传感器设置2	966
				低功耗模式设置	966
				FIFO使能设置	966
				电源管理设置2	967
			1.5.2 读取ICM-20608-G的设备ID	968
			1.5.3 读取ICM-20608-G的温度信息	968
			1.5.4 读取ICM-20608-G的加速度信息	969
			1.5.5 读取ICM-20608-G的角速度信息	970
		1.6 上机实验	972
			1.6.1 SPI控制器初始化测试（无示波器可不进行观察试验）	972
			1.6.2 SPI控制器回环测试	972
			1.6.3 读取ICM-20608-G的设备ID	974
			1.6.4 读取ICM-20608-G的传感器信息	974
	第十九章  百问网传感器模块介绍	975
		1.1 模块的分类	975
		1.2 通用模块	976
		1.3 扩展板介绍	977
		1.4 模块原理图和芯片资料	978
	第二十章  IRDA红外遥控模块	979
		1.1 红外遥控简介	979
		1.2 IRDA红外遥控模块硬件设计	979
		1.3 IRDA红外遥控模块软件设计	981
			1.3.1 红外遥控器协议	981
			1.3.2 编程思路	982
			1.3.3 编写GPIO函数	983
			1.3.4 高精度的延时函数	983
			1.3.5 接收起始信号	984
			1.3.6 判断是引导码还是连发码	984
			1.3.7 接收1位数据	985
			1.3.8 解码函数	985
		1.4 IRDA红外遥控模块测试	987
	第二十一章  DHT11温湿度模块	988
		1.1 DHT11简介	988
		1.2 DHT11模块硬件设计	988
		1.3 DHT11模块软件设计	989
			1.3.1 DHT11通信协议	989
			1.3.2 数据格式	990
			1.3.3 编程思路	990
			1.3.4 编写GPIO函数	991
			1.3.5 编写DHT11温湿度模块初始化函数	993
			1.3.6 编写DHT11 开始信号函数	993
			1.3.7 编写等待响应、结束信号函数	993
			1.3.8 编写读取一个字节函数	994
			1.3.9 综合起来，编写读取数据的函数	995
		1.4 DHT11模块测试	996
	第二十二章  DS18B20温度模块	997
		1.1 DS18B20简介	997
		1.2 DS18B20模块硬件设计	997
		1.3 DS18B20模块软件设计	998
			1.3.1 存储器介绍	998
			1.3.2 通信时序	999
			1.3.3 常用命令	1000
			1.3.4 怎么使用命令：流程图	1001
			1.3.5 命令示例1：单个DS18B20温度转换	1003
			1.3.6 命令示例2：指定DS18B20温度转换	1003
			1.3.7 编程思路	1004
			1.3.8 编写GPIO函数	1004
			1.3.9 编写时间精确的电平输出函数	1006
			1.3.10 编写DS18B20初始化函数	1006
			1.3.11 编写读写1位数据函数	1006
			1.3.12 编写读写1字节数据的函数	1007
			1.3.13 编写读温度数据函数	1008
		1.4 DS18B20模块测试	1010
	第二十三章  SR501人体红外模块	1011
		1.1 人体红外模块简介	1011
		1.2 SR501人体红外模块软件设计	1012
		1.3 SR501人体红外模块测试	1016
	第二十四章  SR04超声波测距模块	1017
		1.1 SR04超声波简介	1017
		1.2 SR04超声波测距模块硬件设计	1017
		1.3 SR04超声波测距模块软件设计	1018
			1.3.1 SR04时序及编程思路	1018
			1.3.2 编写GPIO函数	1019
			1.3.3 编写定时器函数	1020
			1.3.4 编写触发函数	1020
			1.3.5 编写中断处理函数	1021
		1.4 SR04超声波测距模块测试	1023
	第二十五章  步机电机模块	1024
		1.1 28BYJ-48电机原理	1024
		1.2 步进电机模块硬件设计	1027
		1.3 步进电机模块软件设计	1029
			1.3.1 确定转动节拍对应的引脚值	1029
			1.3.2 先写main函数	1031
			1.3.3 编写GPIO函数	1031
			1.3.4 编写电机顺时针转动函数motor_sw	1032
			1.3.5 编写电机逆时针转动函数motor_aw	1033
		1.4 步进电机模块测试	1034
	第二十六章  OLED显示模块	1035
		1.1 OLED简介	1035
		1.2 OLED模块硬件设计	1035
		1.3 OLED模块软件设计	1037
			1.3.1 程序框架	1037
			1.3.2 OLED的基本操作:发命令、发数据	1037
			1.3.3 编写OLED的初始化函数	1038
			1.3.4 OLED的像素显示	1040
			1.3.5 OLED设置地址函数	1040
			1.3.6 OLED清屏函数	1041
			1.3.7 OLED显示字符的函数	1041
			1.3.8 OLED显示字符串的函数	1042
			1.3.9 OLED显示汉字的函数	1043
			1.3.10 编写测试函数	1043
			1.3.11 初始化SPI1控制器	1044
		1.4 OLED模块测试	1046
	第二十七章  DAC模块	1047
		1.1 DAC简介	1047
		1.2 DAC硬件模块设计	1047
		1.3 DAC模块软件设计	1049
			1.3.1 程序框架	1049
			1.3.2 DAC操作方法	1049
			1.3.3 初始化SPI1控制器	1050
			1.3.4 DAC发送数据的函数	1051
			1.3.5 测试函数	1052
		1.4 DAC模块测试	1053
	第二十八章  EEPROM模块	1054
		1.1 AT24C02简介	1054
		1.2 EEPROM模块硬件设计	1054
		1.3 EEPROM模块软件设计	1055
			1.3.1 程序框架	1055
			1.3.2 AT24C02操作方法	1055
			1.3.3 AT24C02读函数	1056
			1.3.4 AT24C02写函数	1056
			1.3.5 测试函数	1057
		1.4 EEPROM模块测试	1058
	第二十九章  GPS模块	1059
		1.1 GPS简介	1059
		1.2 GPS模块硬件设计	1059
		1.3 GPS模块软件设计	1060
			1.3.1 GPS数据格式	1060
			1.3.2 编程思路	1061
			1.3.3 串口初始化函数	1061
			1.3.4 读取GPS信息的函数	1063
			1.3.5 提取信息的函数	1063
			1.3.6 解析信息的函数	1064
			1.3.7 测试函数	1066
		1.4 GPS模块测试	1067
	第三十章  ADC实验_光敏模块	1069
		1.1  光敏电阻简介	1069
		1.2  光敏模块硬件设计	1069
		1.3 IMX6ULL ADC简介	1070
			1.3.1 概述	1070
			1.3.2 ADC时钟	1071
			1.3.3 参考电压选择	1071
			1.3.4 转换控制	1071
			1.3.5 转换完成	1071
			1.3.6 硬件平均功能	1072
			1.3.7 比较功能	1072
		1.4  IMX6ULL ADC寄存器	1073
			1.4.1 控制寄存器ADCx_HC0	1073
			1.4.2 状态寄存器ADCx_HS	1073
			1.4.3 数据结果寄存器ADCx_R0	1073
			1.4.4 配置寄存器ADCx_CFG	1074
			1.4.5 通用控制寄存器ADCx_GC	1076
			1.4.6 通用状态寄存器ADCx_GS	1077
		1.5  编程	1078
			1.5.1 ADC初始化	1078
			1.5.2 获取ADC值	1079
			1.5.3 测试函数	1079
		1.6  光敏模块测试	1080
	第三十一章  CAN和RS485接口	1081
