es调优
    2.缓存预热
        假如说，按照上面的方案去做了，es集群中每个机器写入的数据量还是超过了filesystem cache的一倍，60g数据，filesystem cache就30g，还有30g在磁盘中
        可以自己后台搞个系统，每隔一会就去搜索一下热数据，刷到filesystem cache中。后面用户搜索热数据就是直接去内存里查了
    4.document模型设计
        es里的复杂的关联查询，复杂的查询语法，尽量别用，一旦用了性能一般都不太好。所以要好好设计es里的数据模型。
        写入es的java系统里，就完成关联，将关联好的数据直接写入es中，搜索的时候就不需要利用es的搜索语法
        比如 mysql两个表需要join在写入es的时候java直接将join好的数据写入es，不用es的join语法查询
    5.分页性能优化
        es分页性能比较坑假设每页10条数据，现在要查询第100页，实际上是会把每个shard上存储前1000条数据都查到一个协调节点上，如果你有5个shard，那么就有5000条数据，接着协调节点对这5000条数据进行一些合并，处理。再获取到最终第100页的10条数据。翻页的时候，翻的越深，每个shard返回的数据就越多，协调节点处理数据时间越长，非常坑爹。
        1.不允许深度分页/默认深度分页性能很差。
            系统不允许翻那么深的页，或者告诉产品默认翻的越深性能越差
        2.类似于app里的推荐商品或者微博，不断下拉出现一页一页的。可以用scroll api来进行处理scroll会一次性给你生成所有数据的快照，每次翻页通过游标移动，获取下一页这样子，性能会比上面说的那种分页性能高很多。无论分多少页，性能基本上都是毫秒级的。因为scroll api 只能一页一页往后翻，不允许先第十页再120页。
    设计阶段调优
        3.冷热分离
            1.将大量不搜索的字段，拆分到别的存储引擎里去，这个类似于mysql分库分表的垂直拆分。
            2.可以做类似mysql水平拆分，就是说将大量的访问很少，频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。
            热数据存储ssd，冷数据定期shrink操作更新
        每天凌晨定时对索引做force_merge操作，以释放空间；
        根据业务增量需求，采取基于日期模板创建索引，通过roll over API滚动索引；
         采取curator进行索引的生命周期管理；
        仅针对需要分词的字段，合理的设置分词器；
        Mapping阶段充分结合各个字段的属性，是否需要检索、是否需要存储等
        使用别名进行索引管理；
        分片策略
    es内部压缩方案
    es插件开发
    写入性能优化
        导致的原因
            没有使用批量操作
            使用批量操作，但是值设置不对
            es队列线程设置不合理
        如何优化
            调大批量请求数
            增大刷新间隔
            写入前关闭副本
            禁用refresh
            尽量使用自动生成id
            写入后恢复副本数和刷新间隔
            写入前副本数设置为0
    检索
        如何提升
            profile：true分析，找到根本原因
            硬件层面
            数据层面
                提前数据建模
                减少检索字段
                mapping优化
                避免使用script
                使用近似日期
                只读数据force_merge
                范围检索施一公keyword而非range
            缓存层面
                使用文件系统缓存
                preference优化缓存利用率
        导致慢的原因
            索引设置不合理
            mapping映射字段设置不合理
            psl设置不合理 有优化空间
            返回字段特别多
            慢日志查询
            监控集群状态