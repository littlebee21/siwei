sql优化 - 索引
索引优化
    语法细节优化提高索引效率
        SELECT
        WHERE
            4.范围条件放最后
        ORDER BY
            如果有 order by 的场景，请注意利用索引的有序性
        JOIN ON
            8. 避免使用子查询，可以把子查询优化为 join 操作
                通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。
                子查询性能差的原因：
                子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。
                由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。
        union
        COUNT
        limit分页
            使用延迟关联或者子查询优化超多分页场景？
        其他
            SQL 性能优化的目标
                至少要达到 range 级别，
                要求是 ref 级别，
                如果可以是 consts 最好
            复合索引尽量都用上
    语法细节优化防止索引失效
        COUNT
            避免并发count(*)
        SELECT
            尽量全值匹配
            减少select *
                消耗更多的 CPU 和 IO 以网络带宽资源
                无法使用覆盖索引
                可减少表结构变更带来的影响
        WHERE
            避免在where子句中使用参数
            避免在where子句中对字段进行表达式操作
            组合索引不能跨列
                where和order by不能跨列
            WHERE 从句中禁止对列进行函数转换和计算
                对列进行函数转换或计算时会导致无法使用索引
                不推荐：
                推荐：
            where子查询：不是要使用类型转换
        ORDER BY
        JOIN ON
            超过三个表禁止 join
            多表关联查询时， 保证被关联的字段需要有索引。
        limit分页
        关键字
            避免 LIKE
                尽量左侧不用%
                7，like尽量以常量开头，不要以%开头 
                页面搜索严禁左模糊或者全模糊
            避免使用OR
                9. 尽量不能使用or
                10.OR改UNION效率高
                    - - USE INDEX：建议MySQL使用指定的索引。
                    - IGNORE INDEX：建议MySQL忽略掉指定的索引。
                    - FORCE INDEX：强制MySQL使用指定的索引。
                or的改成in也能更快
            避免 in
                改为exists
            逻辑符号
                注意查询范围，between、>、<等条件会造成后面的索引字段失效
                SQL语句中的IN包含的值不应该过多
                当只需要一条数据的时候，使用limit 1
    更好的创建索引
        在 varchar 字段上建立索引时，必须指定索引长度
        尽可能把所有列定义为 NOT NULL
            7.Null/Not 有影响
                有Not-null约束
                    is null
                        不可达
                    is not null
                        全表扫描
                无Not-null约束
                    is null
                        使用索引
                    is not null
                        全表扫描？？？
        选择列
            选择数据最整齐，最紧凑的数据列来创建索引
            出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
                如果有 order by 的场景，请注意利用索引的有序性
            包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
        覆盖索引
            7. 对于频繁的查询优先考虑使用覆盖索引
                覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引
                覆盖索引的好处：
                    避免 Innodb 表进行索引的二次查询:
                Innodb 是以聚集索引的顺序来存储的，对于 Innodb 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
                可以把随机 IO 变成顺序 IO 加快查询效率:
                由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。
        联合索引
            建组合索引的时候，区分度最高的在最左边
            把字段长度小的列放在联合索引的最左侧
            禁止给表中的每一列都建立单独的索引
                并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
                5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。
        unkey唯一索引
            业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引
        避免
            宁滥勿缺不可泛滥
                限制每张表上的索引数量,单表5个
            尽量避免使用外键约束
                不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
                外键可用于保证数据的参照完整性，但建议在业务端实现
                外键会影响父表和子表的写操作从而降低性能
            避免重复索引示例：primary key(id)、index(id)、unique index(id)
            避免冗余索引示例：index(a,b,c)、index(a,b)、index(a)
    总结；
        模型数空运最快