1. 复习
	[1] 指针与二维数组  
		(1) 通过列指针访问二维数组  
			int a[2][3] = {6,7,8,9,10,11};
			int *p = &a[0][0];
			int i;

			for (i = 0; i < 6; i++) {
				printf("%d %p\n", *(p+i), p+i);
			}
		(2) 通过行指针访问二维数组  
			1) 行地址: 二维数组的数组名, 数组名+1, 刚好移动1行  		
				int a[3][4];
				a		&a[0]
				a+1		&a[1]
				a+2		&a[2]
				...		... 
				a+i		&a[i]
			2) 通过行地址表示二维数组的元素 
				a[i][j]
				*(a[i]+j)
				*(*(a+i)+j)
				*(&a[i][0]+j)
			3) 通过行指针表示二维数组的元素 
				a. 行指针(数组指针)
					数组指针:指向数组的指针  
					数据类型 (*指针名)[元素个数]
					eg: 
						int (*p)[N];
				b. 通过数组指针访问二维数组  
					int a[3][4];
					int (*p)[4] = a;
					
					p[i][j]
					*(p[i]+j)
					*(*(p+i)+j)
					*(&p[i][0]+j)
	
	[2] 字符指针 & 字符串 
		(1) 使用字符数组保存字符串,使用字符指针指向该数组  
			char s[] = "hello world";
			char *p = s;
			
			*p = 'H';  	//可以通过指针修改字符串的内容
		(2) 直接使用字符指针，指向字符串常量  
			char *p = "hello world";	//p 仅仅保存了字符串常量的地址, 字符串常量保存在常量区(只读)
			*p = 'H'; 	//不可以通过指针修改字符串的内容
	
	[3] 多级指针
		(1) 什么是多级指针  
			如果一个指针保存的是另一个指针的地址，则该指针称为多级指针。
		(2) 二级指针
			一级指针: 保存的是某个具体数据的地址 	数据类型 *指针名;
			二级指针: 保存的一级指针的地址			数据类型 **指针名;
			三级指针: 保存的二级指针的地址			数据类型 ***指针名;
			...
		(3) 二级指针的使用 
			int a = 100;
			int *p = &a; 
			int **q = &p; 
			
			*q == p == &a;
			**q == *p == a;
			
	[4] 指针数组  
		(1) 什么是指针数组  
			如果一个数组的所有元素都是指针，则该数组称为指针数组。
			数据类型 *数组名[元素个数];
			eg: 
				int *a[N];
				
				*(a+i) 或 a[i] 		//获取指针数组第i个元素所指向的对象的地址
				**(a+i) 或 *a[i] 	//获取指针数组第i个元素所指向的对象的值
		(2) 理解数组名 
			1) 一维数组的数组名类似与一级指针
				int a[N];
				int *p = a;
			2) 二维数组的数组名类似与数组指针
				int a[N][M];
				int (*p)[M] = a;
			3) 指针数组的数组名类似与二级指针
				int *a[N];
				int **p = a;
				
				*(p+i) 或 p[i] 		//获取指针数组第i个元素所指向的对象的地址
				**(p+i) 或 *p[i] 	//获取指针数组第i个元素所指向的对象的值
				
		(3) 字符型指针数组  
			一般用于保存多个字符串的地址
			char  *ps[5] = {“beijing city”,  “New York”, “London”, “Paris city”, “Moscow city”};
				ps[i]或*(ps+i)			//第i个字符串的地址
				ps[i]+j或 *(ps+i)+j		//第i个字符串的第j个字符的地址
				*(ps[i]+j)或 *(*(ps+i)+j)		//第i个字符串的第j个字符
				
		(4) main 命令行参数  
			int main(int argc, const char *argv[])
			1) argc(argument count) : 命令行参数的个数  
			2) argv(argument vector) : 命令行参数(字符型指针数组:保存了每个命令行参数的地址)
			
			eg： 
				./a.out hello world nice to meet you  
				
				argc = 7;
				char *argv[] = {"./a.out", "hello", "world", "nice", ...};
				
		(5) 指针数组与二维数组  
			将二维数组的每行首元素的地址保存到指针数组时，可以通过指针数组访问二维数组。
			
		
		(6) 指针数组与数组指针的比较
			1)数组指针：	int (*p)[N];	p+1 	移动 N*sizeof(int)个字节(一整数组长度)
			2)指针数组：	int *p[N];		p+1		移动 sizeof(int *)个字节(一个指针元素长度)

2.作业:
	1.设有二维数组 
		int  a[3][4]= {0， 1， 2， 3，4， 5， 6， 7， 8， 9， 10， 11};
		请说明以下表示形式的的含义：
		并写出地址值，设a的起始地址为0x2000.
		a表示 二维数组名，那么 
		*a = ______；0x2000 	
		a + 1, &a[1] 表示_____的首地址	 第2行的首地址 
		a[1], * (a+1) 表示的是元素______的地址。 第2行首元素的地址 
		*(a[1] + 2), *(*(a+1) +2), 和a[1][2]的关系？	相等
			
		2.数组 int a[3][4]， 请用3-4种方法表示a[1][2]的地址？
			&a[1][2]
			a[1]+2
			*(a+1)+2
			&a[1][0]+2
			
		3.计算表达式最后的值？
			int main()
			{
				int a[5][5]={0};
				int (*p)[4] = NULL;
				p = a;
				printf("%d\n", &p[4][2] - &a[4][2]);  //-4
				return 0;
			}
			
		4.加密一个字符串。加密规则是：字符串中所有字母都循环向后4个字母。
		如a--->e、b--->f……x--->b、y--->c、z--->d。A--->E、B--->F……X--->B、Y--->C、Z--->D。例如：
		"Hello World!"--->"Lipps Asvph!"，注意非字母字符不转换。
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				char input[64] = "\0";
				char *p = input;

				printf("请输入一个字符串 :\n");
				scanf("%[^\n]", input);

				while (*p != '\0') {
					if (((*p >= 'a') && (*p <= 'v')) || ((*p >= 'A') && (*p <= 'V'))) {
						*p += 4;
					} else if (((*p >= 'w') && (*p <= 'z')) || ((*p >= 'W') && (*p <= 'Z'))) {
						*p = *p - (26 - 4);
					}
					p++;
				}

				printf("%s\n", input);

				
				return 0;
			}

===================================================================================================================	
3. 函数
	[1] 基本概念 
		(1) 为什么引入函数 
			在C语言中一段功能代码可能会用到很多次，如果每次都写这样一段重复的代码，不但费时费力、容易出错，
		而且交给别人时也很麻烦。所以为了避免使代码变得庞杂、逻辑混乱、程序冗余。
		(2) 什么是函数(Function)
			函数的本质是一段可以复用的完成特定功能的代码模块。可以给函数传递参数，也可以得到返回值。
			
	[2] 函数的定义和声明
		(1) 函数的定义形式
			<数据类型>  <函数名称> (<形式参数说明>)
			{
				函数体;
				return (<表达式>);
			}
			说明: 
				1) 函数名：函数的标识符，使用者可以根据函数名调用该函数。函数名应符合C语言的标识符命名规范，
					且不得重名，不得与系统函数（如printf()等库函数或main()函数）重名。命名应做到“见文知意”而避免
					起简单的函数名。
				2) 数据类型：函数返回值的类型，函数的返回值可理解为函数的计算结果。函数可以没有返回值，但如果有返回值，
				返回值类型需要与函数的数据类型匹配。若该函数不需要返回值，则应将函数类型定义为 void（空类型）。
				数据类型可以省略，默认的类型为整型。
				3) 形式参数说明：函数的形式参数列表，简称形参。形参可以是任意类型的变量，各参数之间用逗号分隔。
					在进行函数调用时，调用函数将赋予这些形参实际的值。如果不需要传递参数，可以省略形参 或 void。
				4)函数体：实现函数功能的代码。
				5)函数返回值：return (<表达式>);语句中表达式的值即函数的返回值，要求必须与函数的数据类型保持一致。
					如果数据类型为void 表示无返回值，可以省略return 表达式也可以写成”return ;”。
					
			示例: 定义的max函数是用来求出2个数中更大的数
				int max (int x, int y)
				{
					int z; 
					z = x > y ? x : y;
					
					return z;
				}
				
			示例: 定义一个函数输出 "hello world"
				void hello (void)
				{
					printf ("hello world\n");
					
					return ; //或者省略
				}
			注意：C语言函数不能嵌套定义
				void func1()
				{
					printf("Welcome to Farsight!\n");
					void func2()
					{
						printf("C语言小白变怪兽\n");
					}
				}

				
	[3] 函数调用形式  
		(1) 函数调用形式
			函数名(实际参数列表);
		其中：
			“实际参数列表”需要确切的数据，也可以是具有确定值的表达式。实际参数就是在使用函数时，
		调用函数传递给被调用函数的数据，用以完成所要求的任务。
		注意:
			1.	函数调用时可能没有实参列表（具体实参情况需要依据形参决定），但是绝对不可以省略括号。
				示例: hello();
			2.	如果实参列表中包含多个实参，则参数间用逗号隔开。实参与形参的个数相等，类型一致且一一对应。
			3.	实参可以是常量、变量或表达式等，但必须有确定的值。在调用时将实参的值赋值给形参。	
			4.	在函数调用过程中，我们把调用函数的函数称为“主调函数”，相应地，被主调函数调用访问的函数称为“被调函数”。
			5.	在定义函数时出现的形参，并不占用存储单元。在调用过程中，形参会被临时开辟内存单元，实参将值传递给形参，
				形参拿到值开始函数的运算。在函数调用结束后，形参单元会被释放。
		(2) 函数调用的方式
			按照函数在程序中出现的不同位置，有以下3中函数调用的方式：
			①　	函数语句：把函数printf作为一个语句。这时不要求函数带返回值，只要求完成一定的操作，如：
				printf(“hello world\n”);
			②　	函数表达式：函数出现在一个表达式中，这种表达式称为函数表达式。这时要求函数返回一个确定的值以参加表达式的运算如：
				i = sum(a, b)
			③　	函数参数：函数调用作为一个函数的实参。如：
				printf(“The sum of a and b is %d\n”, sum(a, b));
				
	[4] 函数的声明
		原则上函数定义要出现在函数调用之前，否则就会报错。但在实际开发中，经常会在函数定义之前使用它们，
	这个时候就需要提前声明。
		所谓声明（Declaration），就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，
	稍后我会把定义补上。
		函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号";"如下形式：
		<数据类型>  <函数名称> (参数类型1 , 参数类型 2，……);
			或
		<数据类型>  <函数名称> (参数类型1  参数名称1, 参数类型 2 参数名称2，……);
		
		例如:

		double  Power(double x, int n) ;
		double  Power(double, int);
			
		练习：编写一个函数，求一个数x的n次方。其中x和n作为函数的参数传递进去。之后写main()函数测试.
			#include <stdio.h>

			int mypow (int x, int n);

			int main(int argc, const char *argv[])
			{
				int x, n;

				printf("请输入x 和 n : \n");
				scanf("%d%d", &x, &n);

				printf("x^n = %d\n", mypow (x, n));
				
				return 0;
			}

			int mypow (int x, int n)
			{
				int i;
				int count = 1;

				for (i = 0; i < n; i++) {
					count = count * x; 
				}

				return count;
			}

	[5] 函数参数传递 
		①　	值传递方式：将需运算的变量的值传递给函数形参的方式称之为“值传递”。(将实参的值赋值给形参)
		形参和实参是两个不同的变量，占用不同的空间，因此，当形参的值发生变化时，并不影响实参的值。
			#include <stdio.h>
			int swap (int x, int y)
			{
				int tmp;

				tmp = x, x = y, y = tmp;

				printf("%s:x = %d, y = %d\n", __func__, x, y);
			}
			int main(int argc, const char *argv[])
			{
				int x, y;

				scanf("%d%d", &x, &y);

				swap (x, y);
				printf("%s:x = %d, y = %d\n", __func__, x, y);
				
				return 0;
			}
		②　	地址传递方式：将需运算的变量的地址传递给函数形参的方式称之为“地址传递”。这种方式是将实参本身的地址传递给被调用的函数。
		因此，被调用的函数种对形参的操作，将直接改变实参的值。
			#include <stdio.h>

			int swap (int *px, int *py)
			{
				int tmp;

				tmp = *px, *px = *py, *py = tmp;

				printf("%s:*px = %d, *py = %d\n", __func__, *px, *py);
			}

			int main(int argc, const char *argv[])
			{
				int x, y;

				scanf("%d%d", &x, &y);

				swap (&x, &y);
				printf("%s:x = %d, y = %d\n", __func__, x, y);
				
				return 0;
			}

	[6] 全局变量与局部变量
		(1) 局部变量 
			定义在函数内部或代码块的变量称为局部变量（Local Variable）
			作用域(变量的有效范围):仅限于函数内部或代码块内部， 离开该函数或代码块后就是无效的，再使用就会报错。
			int f1(int a)
			{
				int b,c;  //a,b,c仅在函数f1()内有效
				return a+b+c;
			}
			int main()
			{
				int m,n;  //m,n仅在函数main()内有效
				return 0;
			}
			
		(2) 全局变量  
			在所有函数或代码块外部定义的变量称为全局变量（Global Variable）
			全局变量的作用域是从定义变量的位置开始直到本文件结束。
			
			示例1：
			int p=1,q=5;		//全局变量 
			float f1(int a)
			{
				int b,c;
			}

			char c1,c2; 		//全局变量
			char f2(int x,int y)
			{
				int i,j;
			}

			int main(){
				int m,n;
				return 0;
			}
			分析: 
			f1可以使用: p, q, a, b, c;
			f2可以使用: p, q, c1, c2, x, y, i, j  
			main可以使用: p, q, c1, c2, m, n 
			
			
			#include <stdio.h>

			int n = 10; 
			void func1()
			{
				int n = 20; 
				printf("func1 n: %d\n", n);		//20
			}
			void func2(int n)
			{
				printf("func2 n: %d\n", n);		//30
			}
			void func3()
			{
				printf("func3 n: %d\n", n);		//10
			}
			int main()
			{
				int n = 30; 
				func1();
				func2(n);
				func3();
			
				{
					int n = 40; 
					printf("block n: %d\n", n);		//40
				}
				printf("main n: %d\n", n);		//30
				return 0;
			}
			
			代码中虽然定义了多个同名变量 n，但它们的作用域不同，在内存中的位置（地址）也不同，所以是相互独立的变量，互不影响，
			不会产生重复定义（Redefinition）错误。
			
			 C语言规定，只能从小的作用域向大的作用域中去寻找变量，而不能反过来，使用更小的作用域中的变量。
	
	[7] 函数与数组 
		(1) 一维数组作参数
			#include <stdio.h>
			#define N 5

			float average(float score[N])
			{
				int i;
				float sum = 0;

				for (i = 0; i < N; i++) {
					sum += score[i];
				}

				return (sum / N);
			}

			int main(int argc, const char *argv[])
			{
				float score[N];
				int i;

				for (i = 0; i < N; i++) {
					scanf("%f", &score[i]);
				}

				printf("平均值 = %f\n", average(score));

				return 0;
			}

			①　	实参数组和形参数组类型保持一致。
			②　	形参数组大小不起任何作用，因为C语言把数组类型的形参当做同级别的指针去处理，不对形参数组大小作检查，不会检查形参的数组是否有越界。在调用时，主调函数的实参将首地址传递给被调函数的形参数组名。
			③　	形参数组可以不指定大小，定义时保留空方括号即可。 
			float avgrage(float array[]);
			④　	除了传递数组名以外，还要传递数组中元素的个数。

			①　	若需要给子函数传递一维数组
			例如：
				float avgrage(float array[]);
			利用指针传递一维数组，可以改写成下面形式：
				float avgrage(float *array);

		
		(2) 二维数组作参数 
			如果形参是多维数组，以二维数组为例，在定义函数时可以省略第一个下标，绝对不可以省略第二个下标。
					
			②　	若需要给子函数传递二维数组
			例如：
				int max_value(int array[][3])；
			利用指针传递二维数组，可以改写成下面形式：
				int max_value(int (*array)[3])；
				
		(3) 指针数组作为参数  
			int main(int argc, const char *argv[])
			{
				...			
				return 0;
			}
			可以改写成
			int main(int argc, const char **argv)
			{
				...			
				return 0;

			}
			练习: 编写函数，输入一个字符串，内有数字和非数字字符，如 a123x456 17960? 302tab5876  将其中连续的数字作为一个整数，依次存放到整型数组a中。
			例如，123放在a[0]，456放在a[1]，统计共有多少个整数，并输出这些数。
			总结：冲锋的思路
				将内容尽可能的放在内部进行操作；
					发起战役
					而不是战争
			#include <stdio.h>

			int sniffer (char s[], int a[]) 
			{
				int i, j;
				int n;
				int count = 0;

				for (; *s != '\0'; s++) {
					if (*s >= '0' && *s <= '9') {
						n = *s - '0';
						s++;
						for (; (*s >= '0' && *s <= '9'); s++) {
							n = n * 10 + (*s - '0');
						}
						a[count] = n;
						count++;
					}
				}

				return count;
			}

			int main(int argc, const char *argv[])
			{
				char s[] = "a123x456 17960? 302tab5876";
				int a[10];
				int i;
				int ret;

				ret = sniffer (s, a);：

				for (i = 0; i < ret; i++)
					printf("%d ", a[i]);
				printf("\n");
				
				return 0;
			}
			作业:  编写函数，输入一个字符串, 实现字符串的反转。 
				例如 "I Love China" => "China Love I"
					"Nice to meet you" => "you meet to Nice"
				思路1：
					遍历字符串
					将每一个找到的字符保存到临时的数组当中：
						因为要返回这个字符串，所以一定是用指针进行计算
						这条思路不成立
					然后将这些字符串进行拼接
					然后返回指向常量的指针；return
				思路2：
					两个内存空间
					1，指针找到每个字符串的首地址，存储
					2，将字符串拷贝到新的内存空间
				
					是修改当前的字符串，还是复制一个字符串，然后输出？
						如果是复制字符串，必须不能存在字符串数组中，因为会因为局部变量形成乱码
					
					如何将二维数组和二维指针进行转换，写出同样效果的不同方法程序

					肉眼重捋顺的方式会不会慢了点

					函数只有内部的栈内存，假如没有全局变量，没有传入的常量池，那么将无法完成对新的内存区域的读写
						所以用全局变量进行尝试；
						也可以使用作用域更大的局部变量进行尝试			
					
						相当于开辟了一块空间
					如何使用指针逆序访问
						操作完成之后，在后面补上0
					字符串题其实可以做总结
						都是遍历操作；
					
					程序可能会出错，所有需要从前向后的进行调试
						取消后面的内容编译通过，然后输出前面的阶段性成果进行校验；
					
					通过遍历之后的计数，可以按照任何顺序进行访问
					代数原理，获取具体的长度
						
					地址是先移动地址， 再取出对应值*

					指针赋值是常量，是无法进行更改的
					最终结果 ver_str2.c
						语法不熟练，编译未通过
					字符串数组可以不初始化？
				总结：	
					上面使用容器进行保存
					然后更改容器的内存空间
	[8] 函数与指针 
		(1) 指针函数
			若一个函数的返回值是指针，则称该函数为“指针函数”。
			指针函数的定义形式为：
			<数据类型>  *<函数名称>  (<参数说明>)  
			{
					...
			}
			示例:  完成
				#include <stdio.h>

				int *choose (int p[3][4], int n) 
				{
					return *(p+n);
				}


				int main(int argc, const char *argv[])
				{
					int score[3][4] = {{88,99,45,66}, {88, 66, 100, 80}, {99, 100, 98, 87}};
					int n;
					int *p = NULL;
					int i;

					printf("please input 1 ~ 3 :\n");
					scanf("%d", &n);
					
					if (n != 1 && n != 2 && n != 3) {
						printf("input error\n");
						return -1;
					}
					n--;

					p = choose(score, n);

					for (i = 0; i < 4; i++) 
						printf("%d ", *p++);
					printf("\n");

					return 0;
				}
				
			注意: 
				1. 函数调用是通过栈实现的。在调用函数时，系统会将被调函数所需的程序空间安排在一个栈中。
					每当调用一个函数时，就在栈顶为它分配一个存储区。每当从一个函数退出时就释放它的存储区。）
				2. 当指针作为函数的返回值的时候，主调函数需要考虑指针指向的数据是否已经被回收.
					指针函数不能返回一个局部变量(数组)地址。
					
				#include <stdio.h>

				char *memory(void)
				{
				//	char s[] = "hello world";	//栈区
					char *s = "hello world";	//常量区
					return s;
				}

				int main(int argc, const char *argv[])
				{
					char *p = NULL;
					p = memory();

					printf("%s\n", p);
					
					return 0;
				}

		(2) 函数指针
			1) 基本概念
				在C语言程序中定义的函数在编译时系统也会对函数代码分配一段存储空间，这段存储空间的起始地址称“函数的入口地址”
				（函数名代表了函数的入口地址）
			
				用于保存函数地址的指针，称为函数指针。
			
			2) 函数指针变量说明的一般形式
				<数据类型> (*<函数指针名称>)(<参数列表>); 
				说明: 
					数据类型：是函数指针所指向的函数的返回值类型；
					参数说明列表：应该与函数指针所指向的函数的形参保持一致；参数列表只写形参类型即可，不必写形参名
					函数指针名称：符合标识符命名规则	
					（*<函数指针名称>）中，*说明为指针，（）不可缺省，表明为指向函数的指针。 
				示例: 
					int (*p)(int, int);	//p是一个函数指针，指向了一个返回值类型为int型，并且有两个int型的形参。
						
			3) 函数指针的赋值
				指针名 = 函数的地址; 
				eg: 
					int max (int a, int b)
					{
						return a > b ? a : b;		
					}
					float min (float a, float b)
					{
						return a < b ? a : b;
					}
					int (*p)(int, int);
				
					p = max;  //直接给出函数名，不用给出参数。(因为是把函数地址赋值给p,与参数无关)。
					或 
					p = &max;
					p = max(a,b); //错误,不能加参数
					p = min;	//错误，与指定的类型不匹配

		
		
		
		
		
		
		
	
	
		
			
			
						