1.复习
	(1) 程序流程控制
		[1] break  
			1) switch 中使用, 表示跳出switch结构
			2) 循环结构中使用, 表示跳出循环  
		
		[2] continue  
			1) 循环结构中使用, 结束本轮循环(本轮循环未执行的代码都被跳过),开启下次循环  
			
		[3] goto  
			无条件跳转, 只能在一个函数内部跳转
			标签: 
				...
				...
				...
			goto 标签;
			
		[4] return  
			1) 用于函数中, 函数结束和返回 
				return 返回值;
				
	(2) 数组
		[1] 什么是数组 
			数组（Array）是一组有序的、类型相同的数据的集合。
			数组（Array）是一种用于存储类型相同的数据的一种构造类型。
			这些数据被称为数组的元素（Element）。
		[2] 定义数组  
			数据类型 数组名[元素个数];
			eg: 
				int a[10];
		[3] 数组元素的引用   
			数组名[下标];	//下标及数组元素的索引，下标从0开始 - (n-1)
			eg: 
				int a[10];
				a[0] ... a[9]
			注意:数组下标不要越界，编译器不检查该类型错误。
		[4] 数组的内存分布  
			数组在内存中是一段连续的线性空间。数组中的元素都按照顺序进行存储  
			
			数组名即数组的首地址  
			eg: 
				int a[10];	//a == &a[0]
			数组的大小 = sizeof(数据类型) * 元素个数
		[5] 数组元素初始化
			1) 一般形式
				类型 数组名[常量表达式]={值,值…};
				eg： 
					int a[5] = {1,2,3,4,5};
			2) 部分元素初始化  
				eg： 
					int a[5] = {1,2};
				未被初始化的元素将会自动初始化为0
			3) 指定元素初始化  
				eg: 
					int a[5] = {
						[2] = 5,
						[4] = 7,
					};
			4) 给全部元素初始化时，可以省略数组的元素个数  
				int a[] = {1,2,3,4,5};
				
2. 作业 
	[作业1] 
		编写程序，实现控制台的猜数字游戏。游戏运行时产生一个0－10之间的随机整数，要求用户从控制台输入数字，
	若输入的数字比产生的数字小，则输出：“太小了，再大一点！”；若输入的数字比产生的数字大，则输出：
	“太大了，再小一点！”，若输入的数字和产生的数字相等，则输出：“恭喜你猜对了！”然后退出程序；
	若用户猜了3次还未猜对，则输出：“你太笨了，下次再来吧！”然后退出程序。
		(1) rand() -- 产生随机数 
		(2) srand() -- 设置种子seed  
		(3) time() -- 获取系统时间
		
		#include <stdio.h>
		#include <unistd.h>
		#include <stdlib.h>
		#include <time.h>

		int main(int argc, const char *argv[])
		{
			int snum;
			int i, input;

			srand(time(NULL));
			snum = rand() % 11;

			for (i = 0; i < 3; i++) {
				printf("请输入一个 0-10 之间的整数: \n");
				scanf("%d", &input);

				if (input > snum) {
					printf("太大了，再小一点\n");
				} else if (input < snum) {
					printf("太小了，再大一点\n");
				} else {
					printf("恭喜你，猜对了\n");
					break;
				}
			}

			if (3 == i) {
				printf("你太笨了，下次再来吧\n");
			}
			
			return 0;
		}

	[作业2] 使用数组存储斐波那契数列前30项，并输出。
		F1=1			(n=1)
		F2=1			(n=2)
		Fn=Fn-1 + Fn-2  (n>=3)		
			
		#include <stdio.h>
		#define N 30
		int main(int argc, const char *argv[])
		{
			int a[N] = {0};
			int i;

			for (i = 0; i < N; i++) {
				if (i < 2) {
					a[i] = 1;
				} else {
					a[i] = a[i-1] + a[i-2];
				}
			}

			for (i = 0; i < N; i++) {
				printf("%d ", a[i]);
			}
			printf("\n");

			
			return 0;
		}
	
	[作业3]：从键盘输入10个学生的成绩，如果遇到大于100或者小于0的成绩需要提示输入错误重新输入。
	之后计算10个学生的总成绩和平均成绩。学生成绩存储在数组中。 
		#include <stdio.h>
		#define N 10
		int main(int argc, const char *argv[])
		{
			int a[N];
			int i;
			int sum;

			for (i = 0; i < N; i++) {
				printf("请输入学生的成绩:\n");
				scanf("%d", &a[i]);

				if ((a[i] > 100) || (a[i] < 0)) {
					printf("数据输入有误，请重新输入\n");
					i--;
				}
			}

			for (i = 0, sum = 0; i < N; i++) {
				sum += a[i];
			}

			printf("sum = %d\n", sum);
			printf("average = %f\n", (float)sum / N);
			
			return 0;
		}
	[作业4]：使用数组法解决约瑟夫环问题
		约瑟夫入狱，监狱内共有33个犯人。某日33名犯人围成一圈，从第一个犯人开始报数，报到数字7的犯人出列，被枪毙，
		下一名犯人重新从1开始报数。依次类推，直至剩下最后1名犯人可被赦免。聪明的约瑟夫在心里稍加计算，算出了最后枪毙的位置，
		他站在这个位置，最终避免了自己被枪毙，逃出升天。
		问：约瑟夫算出的是哪个位置？	12
		提示：对于约瑟夫环问题来说，需要解决3个问题
		·1如何解决数组循环的问题？
		·2如何解决“逢7一杀”这个逻辑？
		·3如何处理“已死之人”？
		
		#include <stdio.h>
		#define N 33
		#define ALIVE 0
		#define DEAD 1

		int main(int argc, const char *argv[])
		{
			int fanren[N] = {ALIVE};
			int i, j;
			int k = 0; 	//表示数组的下标

			for (i = 0; i < N-1; i++) {
				for (j = 0; j < 7; j++) {
					if (k == N) {
						k = 0;
					}
					if (fanren[k] == DEAD) {
						j--;
					}
					k++;
				}
				fanren[k-1] = DEAD;
				printf("第%d号犯人被枪毙\n", k);
			}

			for (i = 0; i < N; i++) {
				if (fanren[i] == ALIVE) {
					printf("第%d号犯人幸存\n", i+1);
				}
			}
			
			return 0;
		}

==============================================================================================================================
3. 一维数组  
	[1] 变长数组
		C99新增了变长数组（variable-length array, VLA）,允许使用变量表示数组的长度。
		例如：
			int lenth = 5; 
			int array[lenth];
			
		注意：变长数组不能改变大小
			变长数组中的”变”不是指可以修饰已创建数组的大小，一旦创建了变长数组，它的大小则保持不变。这里的”变”指的仅仅是：
			在创建数组时，可以使用变量指定数组的长度。
			
	[2] 冒泡排序 	bubble sort
		这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。
			算法描述：
		①　	比较相邻的元素。如果位置不对，就交换它们两个；
		②　	对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大（小）的数；
		③　	针对所有的元素重复以上的步骤，除了最后一个；
		④　	重复步骤1~3，直到排序完成。
		
		示例:   按照从小到大的顺序排序并输出
			5	4	3	2	1
			4	3	2	1	5		第0轮 	4次
			3	2	1	4	5		第1轮	3次
			2	1	3	4	5		第2轮	2次
			1	2	3	4	5		第3轮	1次
									第i轮	n-i-1次
	
		示例：从键盘输入10个各不相同的整数，存储在数组中，按照从小到大的顺序排序并输出。
		
		#include <stdio.h>

		#define N 10
		int main(int argc, const char *argv[])
		{
			int a[N];
			int i, j;
			int tmp;

			printf("请输入10个各不相同的整数 : \n");
			for (i = 0; i < N; i++) {
				scanf("%d", &a[i]);
			}

			for (i = 0; i < N-1; i++) {
				for (j = 0; j < N-i-1; j++) {
					if (a[j] > a[j+1]) {
						tmp = a[j];
						a[j] = a[j+1];
						a[j+1] = tmp;
					}
				}
			}

			for (i = 0; i < N; i++)
				printf("%d ", a[i]);
			printf("\n");

			
			return 0;
		}
	
	[3] 选择排序（Selection Sort）
		算法描述：
		n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：
		①　	初始状态：无序区为R[1..n]，有序区为空；
		②　	第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，
			将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；
		③　	n-1趟结束，数组有序化了。
		
		示例:  
		初始状态	6	4	7	2	5
		第1轮 		2	4	7	6	5
		第2轮		2	4	7	6	5
		第3轮 		2	4	5	6	7
		第4轮		2	4	5	6	7	
		示例：从键盘输入10个各不相同的整数，存储在数组中，按照从小到大的顺序排序并输出。
		
		
		#include <stdio.h>
		#define N 10
		int main(int argc, const char *argv[])
		{
			int a[N];
			int i, j;
			int tmp, min;

			printf("请输入10个各不相同的整数 : \n");
			for (i = 0; i < N; i++) {
				scanf("%d", &a[i]);
			}

			for (i = 0; i < N-1; i++) {
				min = i;
				for (j = i+1; j < N; j++) {
					if (a[j] < a[min]) {
						min = j;
					}
				}

				if (min != i) {
					tmp = a[min];
					a[min] = a[i];
					a[i] = tmp;
				}
			}

			for (i = 0; i < N; i++)
				printf("%d ", a[i]);
			printf("\n");
			
			return 0;
		}

4.二维数组
	[1] 多维数组
		有两个或两个以上下标的数组称为多维数组（multidimensional array）。
		其说明的一般形式如下： 
			<存储类型>   <数据类型>   <数组名>[<常量表达式1>][<常量表达式2>]…[<常量表达式n>] ;
		例如：
			double  b[3][4][5];   //定义了一个三维双精度实型数组b
			
	[2] 二维数组的定义
		二维数组的声明方式：
			数据类型　数组名[常量表达式][常量表达式]；
		示例：
			int a[2][3];//定义一个2*3的二维int型数组
			float f[3][4];//定义一个3*4的二维float型数组
			
	[3] 二维数组内存的存储结构 
		二维数组常常被称为矩阵（matrix）。把矩阵想成行(row)和列(column)的排列方式，更有助于形象化地理解二维数组地逻辑结构。
		但是内存却是连续编址的，按一维线性排列的。
		存储形式：二维数组在内存中是按行的顺序存放的，即先存放第一行的元素，再存放第二行的元素,……。 
		
	[4] 深入理解多维数组（二维数组）
		在C语言中我们可以将二维数组视为一种特殊的一维数组，它的元素又是一个一维数组。
		例如，上图的二维数组 int a[3][4]。可以理解成由三个元素a[0]，a[1]，a[2]组成的数组，每个元素a[i]是包含四个元素的一维数组：
		
		因此在C语言中的多维数组其实就是元素为数组的数组。
		
	[5] 二维数组元素的引用及初始化 
		(1) 二维数组元素的引用 
			数组名[行下标][列下标];		//从0开始计数
			例如：ary[1][3] = 12;
			
		(2) 二维数组初始化  
			1) 分行初始化
				int a[3][4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
				每行的元素使用花括号分隔开，中间用逗号分隔开，如果有未写的则默认为0。
			2) 线性初始化
				把所有的元素都写在一个花括号内，这样会按照数组在内存中的存储顺序给二维数组赋值。例如：
				int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
				类似于一维数组，如果有未写的则默认为0。
			3) 全部元素初始化
				可以提供全部元素的初值，这样常量表达式1（即第一个下标）可以缺省不写，系统会根据输入的多少来计算行数。
			但常量表达式2（即第二个下标）不可缺省。例如：
				int a[][4]={1,2,3,4,5,6,7,8,9,10,11,12};
			注意：第一维的长度可以省略，但是第二维长度不能省，例如：
				int a[3][]={1,2,3,4,5,6,7,8,9,10,11,12};
				编译程序时，会有语法错误
	
		练习1: 自定义一个 3*4 的矩阵(元素自拟)，输出矩阵中值最大的元素，并输出其数组下标。
			#include <stdio.h>
			int main(int argc, const char *argv[])
			{
				int a[3][4] = {
					{66, 88, 55, 6},
					{5, 99, 67, 89},
					{65, 3, 22, 77}
				};
				int i, j;
				int max, maxi = 0, maxj = 0;
				max = a[maxi][maxj];

				for (i = 0; i < 3; i++) {
					for (j = 0; j < 4; j++) {
						if (a[i][j] > max) {
							max = a[i][j];
							maxi = i; 
							maxj = j;
						}
					}
				}

				printf("最大值为 a[%d][%d] = %d\n", maxi, maxj, max);
				
				return 0;
			}

		作业：打印杨辉三角型前10行
		杨辉三角型：杨辉三角型是形如以下矩阵的三角形：
		1
		1 1
		1 2 1
		1 3 3 1
		1 4 6 4 1
		1 5 10 10 5 1
		……

5.字符串与字符数组
	[1] 字符串
		字符串常量是由一对双引号括起来的，以’\0’为结束标志的一组字符序列。
	[2] 字符数组的定义
			在C语言中没有专门的字符串变量，通常用一个字符数组来存储一个字符串。因此当一个字符串存入一个数组时，
		也把结束符’\0’存入数组，并以此作为该字符串是否结束的标志。
		
		字符数组的定义形式如下：
		char c[10], ch[3][4];
	[3] 字符数组初始化
		(1) 逐个元素初始化
			示例1：
				char ch[6]={‘h’,’e’,’l’,’l’,’o’,’\0’};
			示例2：char diamond[][5]={
					{'.', '.','*'},
					{'.','*','.','*'},
					{'*', '.', '.', '.' ,'*'},
					{'.','*', '.','*'},
					{'.', '.','*'}
				};
		(2) 使用字符串常量为数组元素赋值
			示例1：char ch[6]={“abcde”};
				   char ch[6]=“abcde”;
			示例2： 
				char fruit[][7]={
					“Apple”,
					”Orange”,
					”Grape”,
					”Pear”,
					”Peach”
				};
		（3）定义空的字符串：
			char s1[64] = {'\0'}
			要足够的大，要有初始化内容
	[4] 字符串的输入与输出  
		printf, scanf 直接使用%s格式控制符即可。
		示例: 
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				char string[] = {'h', 'e', 'l', 'l', 'o', '\0'};
				char fruit[][7] = {
					"Apple", "Orange", "Grape", "Pear", "Peach"
				};

				printf("%s\n", string);
				printf("%s\n", fruit[0]);
				
				return 0;
			}
		不过，使用%s输入整个字符串需要注意以下几点：
		①　	因为C语言不检查数组下标越界问题，因此如果直接键入字符串给字符数组，需要将字符数组设置的足够大，
		这样才不会丢失数据。
			%ns, n为一个正数,获取字符串,最多不超过n个字符
		②　	输入字符串给字符数组，注意scanf()的第二个参数不要带&（取地址符）。因为数组名就代表了数组的地址。
		③　	用scanf输入地字符串里面可能有空格、制表符等空白字符，空白字符后面地字符不能被存入到数组中
			%[a-z], 获取a-z之间的字符，一旦遇到!a-z字符则停止 
			%[0-9], 获取0-9之间的字符，一旦遇到!0-9字符则停止 
			%[^=], 获取字符串,一旦遇到 = 则停止
			%[^\n],获取字符串,一旦遇到 \n 则停止   常用

		[5]	字符串处理函数 
		(1) 字符串拷贝strcpy与strncpy
			#include <string.h>

			char *strcpy(char *dest, const char *src);
			char *strncpy(char *dest, const char *src, size_t n);
			
			函数说明：
				[1] strcpy把 src 所指向的字符串复制到 dest。
				[2] strncpy把 src 所指向的字符串复制到 dest, 最多复制 n 个字符。
			参数：
				dest : 指向用于存储复制内容的目标字符数组。
				src : 要复制的字符串(可以是字符串常量也可以是字符数组)
				n ：指定要从源中复制的字符数。
			示例: 
				#include <stdio.h>
				#include <string.h>

				int main(int argc, const char *argv[])
				{
					char s1[32] = {"\0"};
					char s2[] = "I Love China";

					strncpy(s1, s2, 6);

					printf("%s\n", s1);
					
					return 0;
				}
			注意：目标数组 dest 不够大，而源字符串的长度又太长，可能会造成缓冲溢出的情况。
		
		(2) 字符串拼接strcat与strncat
			#include <string.h>

			char *strcat(char *dest, const char *src);
			char *strncat(char *dest, const char *src, size_t n);
			
			函数说明：
				[1] strcat把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。
				[2] strncat把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。
			参数：
				dest ：指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。
				src ：指向要追加的字符串
				n : 要追加的最大字节数
				
		(3) 字符串比较strcmp、strncmp、strcasecmp 、strncasecmp
			#include <string.h>

			int strcmp(const char *s1, const char *s2);
			int strncmp(const char *s1, const char *s2, size_t n);
			int strcasecmp(const char *s1, const char *s2);
			int strncasecmp(const char *s1, const char *s2, size_t n);
			
			函数说明：
				[1] strcmp 把s1 所指向的字符串和 s2 所指向的字符串进行比较。
				[2] strncmp把s1 所指向的字符串和 s2 所指向的字符串进行比较，最多比较前 n 个字符
				[3] strcasecmp把s1 所指向的字符串和 s2 所指向的字符串进行比较（忽略大小写）。
				[4] strncasecmp把s1 所指向的字符串和 s2 所指向的字符串进行比较（忽略大小写），最多比较前 n 个字节
			参数：
				s1 ：要进行比较的第一个字符串。
				s2 ：要进行比较的第二个字符串。
				n ：要比较的最大字符数。
			返回值：
				如果返回值 < 0，则表示 s1 小于 s2。
				如果返回值 > 0，则表示 s1 大于s2。
				如果返回值 = 0，则表示 s1 等于 s2。
		
		(4) 字符串长度strlen
			 #include <string.h>

			size_t strlen(const char *s);
			函数说明：
				计算字符串 s 的长度，直到空结束字符’\0’，但不包括空结束字符’\0’。
			参数：
				str : 要计算长度的字符串。
			返回值: 
				该函数返回字符串的长度,但不包括’\0’。
			注意：sizeof()与strlen()的区别：
				sizeof()的长度是整个字符数组的总长度，其中包括'\0'；而strlen()不包括'\0'。
				sizeof 是运算符 
				strlen 是库函数

			

				

			
			
	

			

			
			



		
		



		

	
			
			
			
			
			