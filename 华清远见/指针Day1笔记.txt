1. 课程安排
	(1) C语言补习  
		[1] 运算符 & 表达式  
		[2] 变量 & 常量  
		[3] 输入/输出函数  
		[4] 程序结构 (顺序、选择、循环)
		[5] 数组(一维、二维数组、字符数组&字符串)
		[6] 常用库函数
		
	(2) C语言高级  
		[1] 指针 
		[2] 指针与数组
		[3] 二级指针
		[4] 函数与指针与数组 
		[5] 构造类型  
			(1) struct 结构体 
			(2) union 共用体  
			(3) enum 枚举型
			(4) typedef 类型重定义
		[6] Make 工程管理 
		[7] shell 脚本
		
=================================================================================================================
2. 指针基础
	[1] 基本概念 
		(1) 地址：在计算机内部存储器（简称内存）中，每一个字节单元（8位），都有一个编号，称为地址。
			(在32位计算机中，地址是由32位（bit）构成的2进制数，占4字节（byte），通常由一个8位的16进制数来表示)
			常以16进制显示
			地址格式说明符 %p
		(2) 指针: 在C语言中，专门用来保存地址的变量，称为“指针变量”，简称“指针”。
			(在32位计算机中,指针类型变量长度占4字节(byte))
		(3) 指针的目标：指针的目标变量简称为指针的目标。指针变量存储了某个对象的地址，则该对象视为指针的目标。
			指针变量指向了该对象。
			
			在不影响理解的前提下，“指针”、“指针变量”和“地址”不做区分，统称“指针”。
			
	[2] 定义指针变量
		用法：
			<数据类型名> *<指针变量名>
		说明: 
			数据类型可以是基本类型也可以是构造类型，指针的目标的数据类型，而非指针本身的数据类型
			*<指针变量名>：指针变量的变量名。前面加*代表这是一个指针变
		示例: 
			char *s; 	//s是一个指向字符类型数据的指针
			int *p;		//p是一个指向整型数据的指针
			float *f;	//f是一个指向单精度浮点型数据的指针
			指针的数据类型 ：(数据类型 *)
			
		注意：在C语言的官方文档内，推荐定义指针时指针运算符" * "要紧贴指针变量名，而不要挨着数据类型名。 
		
	[3] 指针变量的使用 
		(1) 运算符
			在这里需要熟练掌握两个与指针有关的运算符：&和*
			&：取地址运算符
			*：定义指针变量
			   取指针所指向空间(对象)的内容（或称“间接访问运算符”）
			两个运算符互为逆运算。例如 ： "*(&a) == a"  
										
		(2) 指针变量的赋值与初始化 
			1)初始化  
				int a;
				int *p = &a;	
			2)先定义指针变量再赋值  
				int a = 100;
				int *p; 
				
				p = &a;
		(3) 引用指针变量所指向的内容
			方法: *指针变量名
			示例: *p 
		(4) 引用变量本身的内容
			指针变量也是可以输出的，用格式控制%p
			printf("%p",p);	//打印指针p所存放的地址
			
		总结：
			p  指针变量，内部存放的是目标的地址；
			*p 取目标的值，目标内存数据；
			&a 取变量的内存地址;
			&p 指针变量占用存储区域的地址
		示例: 
			#include <stdio.h>

			int main(int argc, const char *argv[])
			{
				int a = 100;
				int *p;

				p = &a;
				printf("*p = %d\n", *p);
				*p = *p + 100;
				printf("*p = %d\n", *p);
				printf("a = %d\n", a);
				printf("p = %p\n", p);
				printf("&a = %p\n", &a);
				printf("&p = %p\n", &p);

				
				return 0;
			}
	[4] 指针的大小
		注意：
		指针变量存储的是一个地址值，而地址是4字节，因此指针大小就是4字节。指针占内存空间大小与指针类型无关。
		
		#include <stdio.h>

		int main(int argc, const char *argv[])
		{
			int a, *p = &a;
			char b, *q = &b;
			double c, *r = &c;

			printf("sizeof(p) = %d\n", sizeof(p));
			printf("sizeof(*p) = %d\n", sizeof(*p));
			printf("sizeof(q) = %d\n", sizeof(q));
			printf("sizeof(*q) = %d\n", sizeof(*q));
			printf("sizeof(r) = %d\n", sizeof(r));
			printf("sizeof(*r) = %d\n", sizeof(*r));
			
			return 0;
		}
		练习：输入a和b两个整数，按先大后小的顺序输出这两个整数。要求使用指针。
		
	[5] 指针运算
		(1) 算术运算 
			注意：不同数据类型的两个指针实行加减整数运算是无意义的。
			1) 	运算符:+ 	计算形式: 	px+n	代表指针向地址大的方向移动 n 个 数据。
									移动后的地址量是： (px) + sizeof(px的类型) * n
			2) 	运算符:- 	计算形式: 	px-n	代表指针向地址小的方向移动 n 个 数据。
									移动后的地址量是： (px) - sizeof(px的类型) * n
			3)	运算符:-	计算形式:	px-py	表示两个相同类型指针间相差数据的个数，而不是一个地址量。
										px - py的结果是  (px - py) /sizeof(数据类型)		
			4)	运算符:++或-- 	计算形式: px++ 或 ++px 		指针变量向地址大的方向移动一个数据。
										  px-- 或 --px  	指针变量向地址小的方向移动一个数据。
			
			小结：指针自增与自减
			①　	p++(或 p+=1)： 使p指向下一个元素
			②　	*p++：  ++与* 具有相同优先级且结合方向自右向左, 等价于*(p++)， 先取*p的值，然后p再自加，指向下一个元素。
			③　	*(p++) 与 *(++p) 作用不同。 前者是先取*p的值，再使p自加。后者先使p自加，再取自加后指向的内容。
			④　	++(*p) 或 (*p)++： 表示将p指向的元素的值加1.

		(2) 关系运算
			不同数据类型的指针之间关系运算没有意义
			指针关系表示两个指针在内存位置的高低关系。
			
			int *p = &a; 
			
		(3) 赋值运算
			1）把一个普通变量的地址赋给一个具有相同数据类型的指针 
			例如：
				   double  x=15,  *px  ;
					px=&x;
			2）把一个已有值的指针变量赋给具有相同数据类型的另一个指针变量，例如，
				   float  a , *px,  *py  ; 
				   px = &a  ;
				   py = px  ;
			3）把一个数组的地址赋给具有相同数据类型的指针。例如，
				   int  a[20],  *pa;
				   pa = a;   //等价 pa = &a[0]
		
			示例: 
					#include <stdio.h>
					int main(int argc, const char *argv[])
					{
						int a;
						int *p = &a;

						char b;
						char *q = &b;

						double c; 
						double *r = &c;

						int d = 1;
						int e = 2;
						int f = 3; 
						int g = 4;
						int *s = &g;
						int *u = &d;
						printf("p = %p\n", p);
						printf("p - 1 = %p\n", p-1);
						printf("p - 2 = %p\n", p-2);
						printf("p + 1 = %p\n", p+1);
						printf("p + 2 = %p\n", p+2);
						
						printf("q = %p\n", q);
						printf("q - 1 = %p\n", q-1);
						printf("q - 2 = %p\n", q-2);
						printf("q + 1 = %p\n", q+1);
						printf("q + 2 = %p\n", q+2);

						printf("r = %p\n", r);
						printf("r - 1 = %p\n", r-1);
						printf("r - 2 = %p\n", r-2);
						printf("r + 1 = %p\n", r+1);
						printf("r + 2 = %p\n", r+2);

						printf("s = %p\n", s);
						printf("u = %p\n", u);

						printf("p - s = %d\n", p - s);
						printf("u - s = %d\n", u - s);
						return 0;
					}

			练习:  
				1.指针的加减法：
				char a = 100;
				char *p = &a;
				若：a的地址为 0x10 0000,则
					p+1 = 0x______; 0x10 0001			
					*p + 1 = _____; 101		
					(int )p + 1 = 0x______;	0x10 0001
					(int *)p + 1 = 0x______;0x10 0004
					(short *)p + 1 = 0x______; 0x10 0002
					
	[6] const 指针
		(1) const 表示的使变量常量化，即不可修改。
			int  const a = 9;
			a = 10; //报错，a为const修饰不可改变。
			const int a 与 int const a， const可以在int的左右位置。
			
		(2) const 指针  
			1) 常量化的指针的对象
				const  <数据类型>  *<指针变量名称>;
				说明：常量化指针目标是限制通过指针改变其对象的值。
				
			2) 常量化指针变量 
				<数据类型>  * const <指针变量名称>= <指针运算表达式>;
				说明：常量化指针变量,说明：常量化指针变量,使得<指针变量>的值不能修改（即只能指向同一个对象）。
				但可以通过 * <指针变量名称> 修改指针所指向的对象的值。  
			3）常量化指针变量及其对象
				const  <数据类型>  * const <指针变量名> = <指针运算表达式>  ; 
				说明：常量化指针变量及其对象，使得既不可以修改<指针变量>的值，也不可以通过*<指针变量名称>修改指针所指向对象的值。
					
	[7] void 指针
		我们暂时无法确定指针所指向数据的类型，此时我们可以使用空类型指针void *来暂时表示指针的类型。
		因为void类型指针可以赋值给其他任意类型的指针，而其他类型不能相互赋值。	
		其他任意类型的指针可以给void类型指针赋值。
		
		实际在使用时void指针需要转换成确定类型的指针类型。
		
		malloc 申请内存空间
		
	[8] 野指针与空指针
		(1) 野指针  
			这时这个指针指向一段未知内存，这样的指针就称为“野指针”。
			野指针产生的原因主要有两个：
				1.定义指针变量时未初始化或之后未指向正确的对象
				2.内存释放后指针未及时置空

			#include<stdio.h>
			int main()
			{
				int *p;
				*p = 100;//p此时是野指针，对野指针进行操作，非法
				return 0;
			}

			Segmentation fault (core dumped)	段错误，非法访问内存
			
			野指针无法通过语法检查而查出错误，只能通过编程人员的自身素养规避。
		初学者要十分小心使用指针变量，尤其不要出现野指针。
		
		(2) 空指针  
			C语言中空指针，指的是指针变量存了零号地址（例如：int *p = 0）。用于表明指针未指向任何内存。
				(void *) 0
				NULL 是一个标准规定的宏定义
			初学者要养成良好习惯：若定义指针后暂时不指向任何对象，应该在定义时就把该指针置空防止出现野指针。
				指针初始化时
				内存释放后，及时将指向该段内存的指针置 NULL

3. 指针与一维数组
	[1] 数组元素的访问 
		1) 下标法：通过变址运算符”[ ]”访问数组元素，如a[i]。
			int a[10];
		2) 指针法：在数组中，指针的加法相当于指向数组的下一个元素，指针的减法相当于指向数组的上一个元素。
			int a[10];
			int *p;
			p = a; 或 p = &a[0]
			
	p+0	==	&a[0]
	p+1	==	&a[1]
	p+2	==	&a[2]
	p+3	==	&a[3]
	p+4	==	&a[4]
			.
			.
			.
	p+i ==	&a[i]		
	
	*(p+i) == *&a[i] == a[i] == p[i] == *(a+i)		
	
	注意：
		上例中数组元素访问过程中，数组地址（数组名）与指针变量具有相同的访问效果。指针变量是变量。
		数组地址(数组名)是常量，不能自加或自减，不能改变。
			p++		正确
			a++		错误
	指针与数组常见操作总结:
		数组			指针表示		含义
		array			&array[0]	 数组名是第一个元素的地址
		*array			array[0]	 数组的第一个元素值
		array + i		&array[i]	 数组第i个元素的地址
		*(array + i )	*(&array[i]) == array[i]	 数组第i个元素
		*array + m		array[0] + m	数组第一个元素加m
		*array++ 		error			error
		
	[2] array与&array之间的区别
		大家都应该知道，array和&array[0]代表的都是数组首元素的首地址，而如果你将&array的值打印出来，
	会发现该值也等于数组首元素的首地址，但是其含义是不同的。
		array+1或 &array[0]+1，表示数组下一个元素的地址。
		&array 代表整个数组的地址
	所以 &array + 1 应该移动整个数组的大小(sizeof(a));
	
		#include <stdio.h>

		int main(int argc, const char *argv[])
		{
			int a[10];

			printf("a = %p\n", a);
			printf("&a[0] = %p\n", &a[0]);
			printf("&a = %p\n", &a);
			
			printf("a+1 = %p\n", a+1);
			printf("&a[0]+1 = %p\n", &a[0]+1);
			printf("&a+1 = %p\n", &a+1);
			return 0;
		}
		
	作业:
		1.int  main()
			{   
				int a[]={6,8,7,6,2,7,3};
				int y,*p=&a[1];
				y=(*--p)++;	
				printf(“%d  ”,y);  		
				printf(“%d”,a[0]); 		
			} 

		2. int a[] = {1, 2, 3, 4, 5};
			int *p = a, b;
			b = ++(*++p);
			printf("%d\n", b);		

		3. int a[]={1, 3, 5, 7, 9}, *p = a;
			表达式为5的是: 			
			A.p+=2; p++
			B.p+=2; *++p
			C.p+=2; (*p)++
			D.p+=2; *p++
			
		4.用指针将整型组s[8]={1,2,3,4,5,6,7,8}中的值逆序存放。
				=> 8,7,6,5,4,3,2,1
		
		5.编写一个程序实现功能：将字符串”Computer Science”赋给一个字符数组，
		然后从第一个字母开始间隔的输出该字符串，用指针完成。



				
			

			
			
			
			
			
			
			

		

			



















		