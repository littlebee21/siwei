

通信意义:替代函数调用
	多线程： 同步互斥的调用任务
	单线程： 在框架的观察者模式下，动态的调用任务

通信的本质: 将固定的函数调用变成动态的函数调用
	2,通信要素：执行内容，执行参数


框架：因各种原因造成的无法进行访问
从上到下，依次添加，依次解决
核心：获取创建数据结构时的，栈柄



	进程间通信:
	线程间通信：


	堆栈区域的限制：
		目的：获取有意义的指针
		作用域：
			全局作用域： 得到指针就行
				1, 静态变量
				2，堆变量: 信号,让所有对象伺服
			局部作用域： 不用指针 
				2, 回调函数
				3，栈对象，main函数定义的变量, 
				   栈对象可以被堆对象替换 
				   栈对象和堆对象配合使用  左站 = 右堆
				   手段：函数参数,对象赋值,引用传递

	代码区域的限制：
		4,命名空间的限制：类+函数+方法
		3,对象之间的通信：+封装关键字的限制
		2,链接之间的访问



	数据结构的限制：
		机制对比：
			1,传统链表,
				缺点：前提要找到对应的对象地址：要写好长才能到链表尾部,麻烦--- javascript-----c
				优点: 效率高，所有的方法都是基于这种方法
				静态类型的访问：
						执行和访问的主体：函数：
							面向对象为实现解耦
							面向对象中函数有了 归属类型
							所以函数的访问内容，只限制于private成员，将功能分包出去
							eg； 刘  牛  流奶
								刘不会直接去访问流奶
								而是操控牛去访问流奶
							eg:  windows   dialog   checkbox 

				动态函数的访问：
						1,回调函数：将本类函数的地址+参数 传递到被调用的函数的参数中

			修改原理:
			2,信号和槽：直接访问，效率低  ---qt
			4,依赖注入，当使用的时候再进行注入(控制反转)  --java

			封装:
			1,类和抽象像类库：提供抽象类型，别人写的传统链表，直接成员访问,继承之后
			3,STL:提供API，简化手动访问

		3,数据结构之间的访问：受到链表类似地址的限制
		4,各种数据类型封装成图的形式


	访问运算符：
            坐标访问
            名字访问
				shell脚本语言： $访问 $# $@
            指针/引用访问  
				->访问 
				::访问
			特殊符号访问：
    运算符优先级：
		1，递归解释：例如L数组指针，指针数组，按照运算符优先级进行运算，运算后的整体结果作为下次运算的内容

                

