0.并发编程

常见的生产合作方式：
    并发编程的设计模式 emmmmmmx
    并发问题的变化因素：数据数量，读写;
    并发问题的本质问题：竞争和合作;  
    并发的根本目的：提高效率;

核心问题：
同步：同步是更高级的互斥，有时许的要求:
互斥：相同时间这一资源只能被一个进程运行


 
线程安全问题：对资源的访问控制： emmmmxxxxxxxxxx
1,死锁问题：
2,锁优化：锁升级问题：
3,锁的不可重入问题：对锁状态的判断；trylock的方式
4,读写问题：
	


1,同步问题：
	单个数据的同步问题：事务问题：一致，隔离，有序，原子，事务隔离级别
	多个数据的同步问题：多方问题：数据库和缓存问题：辅助控制资源        


2,互斥问题：
	应用层面：线程安全问题 emmmmmmx
	操作系统：线程进程之间的通信 emmmmxmmx 

应用层面的的解决方案：
	线程间通信：
		1,信号层面：用户线程发送信号，内核线程获取，软中断系统调用，
		2,全局变量和堆区对象：全局变量实现的进程间通信的机制模仿操作系统进程间通信	
			vue:父子组件之间传递数据
			qt：对象之间，信号和槽数据传递
	进程间通信
		3,需要内核参与的：
		软中断：内核线程，基于任务队列, 可以睡觉
		中断: linux中断 = 硬件中断（上半部）+ 软中断（下半部）;



操作系统提供的进程和线程的解决方案
	1,内核对线程和进程的管理：
	创建
		fork进行
		pthread.start
		中断和线程的区别：硬件 软件 区别
	线程和进程间通信
        1，消息传递列
            # 信号 本地socket
            # 管道
            # 消息队列
        2，共享存储类
            共享文件
            # 共享内存
        3，并发控制类
            # 信号量集合
            文件区域锁 外存
            文件锁 外存
        4，网络是进程间通讯的延续： socket
	内存回收：
		避免僵尸进程问题：
        1，父进程wait
        2，祖先进程
        3，系统， 推荐：父线程fork前调用 signal(SIGCHIL,SIG_IGN);
        4，父进程调用signa(SIGCHL，myfunc)，不推荐，只是用父进程只有一个子进程场合

