UCOS操作系统
    进程
        6.系统调用
            系统调用分类（按功能）
                设备管理
                文件管理
                进程控制
                进程通信
                内存管理
            系统调用和库函数的区别
                普通应用程序
                编程语言
                操作系统
                裸机
            系统调用背后的过程
        7.进程的定义、组成、组织方式、特征
            组成
                程序段
                数据段
                PCB
                    进程描述信息
                        进程标识符PID
                        用户标识符UID
                    进程控制和管理信息
                        进程当前状态
                        进程优先级
                    资源分配清单
                        程序段指针
                        数据段指针
                        键盘
                        鼠标
                    处理机相关信息
                        各种寄存器值
            组织方式
                链接方式
                    按照进程装填将PCB分为多个队列
                    操作系统持有指向各个队列的指针
                索引方式
                    根据进程状态的不同，建立几张索引表
                    操作系统持有指向各个索引表的指针
            特征
                动态性
                    进程是程序的一次执行过程，是动态地产生、变化和消亡的
                并发性
                    内存中有多个进程实体，各进程可并发执行
                独立性
                    进程是能独立运行、独立获得资源、独立接受调度的基本单位
                异步性
                    个进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
                结构性
                    每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成
        8.进程的状态与转换
            状态
                运行状态
                    占有CPU，并在CPU上运行
                就绪状态
                    已经具备运行条件，但由于没有空闲CPU，而暂时不能运行
                阻塞状态
                    因等待某一事件而暂时不能运行
                创建状态
                    进程正在被创建，操作系统为进程分配资源、初始化PCB
                终止状态
                    进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB
            进程状态间的转换
                就绪态->运行态
                运行态->就绪态
                运行态->阻塞态
                阻塞态->就绪态
                运行原理图
        9.进程控制
            基本概念
                进程控制就是要实现进程状态的转换
                进程控制用原语实现
                    原语用关/开中断来实现
                    原语是一种特殊的程序
                    原语的执行必须一气呵成，不可中断
            进程控制相关原语
                进程的创建
                    创建原语
                        申请空白PCB
                        为新进程分配所需资源
                        初始化PCB
                        将PCB插入就绪队列
                    引起进程创建的事件
                        用户登录
                            分时系统中，用户登录成功，系统会为其建立一个新的进程
                        作业调度
                            多道批处理系统中，有新的作业放入内存是，会为其建立一个新的进程
                        提供服务
                            用户向操作系统提出某些请求时，会新建一个进程处理该请求
                        应用请求
                            由用户进程主动请求创建一个子进程
                进程的终止
                    撤销原语
                        从PCB集合中找到终止进程的PCB
                        若进程正在运行，立即剥夺CPU，将CPU分配给其他进程
                        终止其所有子进程
                        将该进程拥有的所有资源归还给父进程或操作系统
                        删除PCB
                    引起进程终止的事件
                        正常结束
                        异常结束
                        外界干预
                进程的阻塞
                    阻塞原语
                        找到要阻塞的进程对应的PCB
                        保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行
                        将PCB插入相应事件的等待队列
                    引起进程阻塞的事件
                        需要等待系统分配某种资源
                        需要等待相互合作的其他进程完成工作
                进程的唤醒
                    唤醒原语
                        在事件等待队列中找到PCB
                        将PCB从等待队列移除，设置进程为就绪态
                        将PCB插入就绪队列，等待被调度
                    引起进程唤醒的事件
                        等待的事件发生
                进程的切换
                    切换原语
                        将运行环境信息存入PCB
                        PCB移入相应队列
                        选择另一个进程执行，并更新其PCB
                        根据PCB恢复新进程所需的运行环境
                    引起进程切换的事件
                        当前进程时间片到
                        有更高优先级的进程到达
                        当前进程主动阻塞
                        当前进程终止
        10.进程通信
            共享存储
                基于数据结构的共享
                基于存储区的共享
            消息传递
                直接通信方式
                间接通信方式
            管道通信
        11.线程、多线程模型
            什么是线程，为什么要引入线程
                可理解为“轻量级进程”
                可增加并发度，减少并发带来的开销
            带来的变化
                资源分配、调度
                    传统进程机制中，进程是资源分配、调度的基本单位
                    引入线程后，进程是资源分配的基本单位，线程是调度的基本单位
                并发性
                    传统进程机制中，只能进程间并发
                    引入线程后，各线程间也能并发，提升了并发度
                系统开销
                    传统的进程间并发，需要切换进程的运行环境，系统开销很大
                    线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小
                    引入线程后，并发所带来的系统开销减小
            线程的属性
                线程是处理机调度的单位
                多CPU中，各个线程可以占用不同的CPU
                每个线程都有一个线程ID、线程控制块（TCB）
                线程也有就绪、阻塞、运行三种基本状态
                线程几乎不拥有系统资源
                同一进程的不同线程间共享进程的资源
                由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
                同一进程中的线程切换，不会引起进程切换
                不同进程中的线程切换，会引起进程切换
                切换同进程内的线程，系统开销很小
                切换进程，系统开销很大
            线程的实现方式
                用户级线程
                内核级线程
                组合方式
            多线程模型
                多对一模型
                    优点：进程管理开销小效率高
                    缺点：一个线程阻塞会导致整个进程都被阻塞（并发度低）
                一对一模型
                    优点：各个线程可分配到多核处理机并行执行，并发度高
                    缺点：进程管理开销大
                多对多模型
                    及二者之所长
        12.处理机调度
            基本概念
                按照某种算法选择一个进程将处理机分配给它
            三个层次
                高级调度（作业调度）
                    按照某种规律，从后备队列中选择合适的作业将其调入内存，并为其创建进程
                中级调度（内存调度）
                    按照某种规则，从挂起队列中选择合适的进程将其数据调回内存
                低级调度（进程调度）
                    按照某种规则，从就绪队列中选择一个进程为其分配处理机
            三层调度的联系、对比
            补充
                进程的“挂起态”
                    就绪挂起
                    阻塞挂起
                七状态模型
        13.进程调度的时机、切换与过程、方式
            时机
                需要进行进程调度与切换的情况
                    当前运行的进程主动放弃处理机
                        进程正常终止
                        运行过程中发生异常而终止
                        进程主动请求阻塞（如等待I/O）
                    当前运行的进程被动放弃处理机
                        分给进程的时间片用完
                        有更紧急的事需要处理（如I/O中断）
                        有更高优先级的进程进入就绪队列
                不能进行进程调度与切换的情况
                    在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换
                    进程在操作系统内核程序临界区
                    在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）
            切换与过程
                狭义“调度”和“切换”的区别
                切换过程
                    对原来运行进程各种数据的保存
                    对新的进程各种数据的恢复
                重要结论
                    进程调度、切换是有代价的，并不是调度越频繁，并发度就越高
            方式
                非剥夺调度方式（非抢占式）
                    只允许进程主动放弃处理机
                剥夺调度方式（抢占式）
                    可由操作系统剥夺当前进程的CPU使用权
        14.调度算法的评价指标
            CPU利用率
                指CPU“忙碌”的时间占总时间的比例
            系统吞吐量
                单位时间内完成作业的数量
            周转时间
                周转时间、平均周转时间
                    周转时间，指作业被提交给系统开始，到作业完成为止的这段时间间隔
                带权周转时间、平均带权周转时间
            等待时间
                指进程/作业处于等待处理机状态时间之和，就是指进程建立后等待被服务的时间之和
            响应时间
                指从用户提交请求到首次产生相应所用的时间
        15.调度算法
            先来先到服务（FCFS）
                算法思想
                    主要从“公平”的角度考虑（类似于排队）
                算法规则
                    按照作业/进程到达的先后顺序进行服务
                用于调度
                    作业
                        考虑哪个作业先到达后备队列
                    进程
                        考虑哪个进程先到达就绪队列
                是否可抢占？
                    非抢占式的算法
                优缺点
                    优点
                        公平、算法实现简单
                    缺点
                        排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好
                是否会导致饥饿
                    不会
            短作业优先（SJF）
                算法思想
                    追求最少平均等待时间，最少的平均周转时间、最少平均带权周转时间
                算法规则
                    最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）
                用于调度
                    作业
                        即可
                    进程
                        称为“短进程优先算法（SPF）”
                是否可抢占？
                    SJF和SPF是非抢占式的算法。但是也有抢占式版本--最短剩余时间优先算法（SRTN）
                优缺点
                    优点
                        “最短的”平均等待时间、平均周转时间
                    缺点
                        不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先
                是否会导致饥饿
                    会。如果源源不断地有短作业/进程到来，可能会使长作业/进程长时间得不到服务，产生“饥饿”现象。一直得不到，则称“饿死”
            高响应比优先（HRRN）
                算法思想
                    要综合考虑作业/进程的等待时间和要求服务时间
                算法规则
                    在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务
                用于调度
                    作业
                        即可
                    进程
                        也可
                是否可抢占？
                    非抢占式。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
                优缺点
                    优点
                        上述两种算法的权衡折中，综合考虑的等待时间和运行时间
                    缺点
                是否会导致饥饿
                    不会
            时间片轮转调度算法（RR）
                算法思想
                    公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应
                算法规则
                    按照各个进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）
                用于调度
                    作业
                    进程
                        用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）
                是否可抢占？
                    若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此属于抢占式算法。
                优缺点
                    优点
                        公平；相应快，适用于分时操作系统
                    缺点
                        由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度
                是否会导致饥饿
                    不会
            优先级调度算法
                算法思想
                    随着计算机发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序
                算法规则
                    每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程
                用于调度
                    作业
                        即可
                    进程
                        也可
                是否可抢占？
                    抢占式、非抢占式都有
                优缺点
                    优点
                        用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对个作业/进程的偏好程度
                    缺点
                        若源源不断地有高优先级进程到来，则可能导致饥饿
                是否会导致饥饿
                    会
            多级反馈队列调度算法
                算法思想
                    对其他调度算法的折中权衡
                算法规则
                    1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
                    2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级队列，则重新放回该队列队尾
                    3.只有第k级队列为空时，才会为k+1级对头的进程分配时间片
                    4.被抢占处理机的进程重新放回原队列队尾
                用于调度
                    作业
                    进程
                        用于进程调度
                是否可抢占？
                    抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原理运行的进程放回k级队列队尾。（也就是算法规则的第4条）
                优缺点
                    优点
                        对各类型进程相对公平（FCFS优点）；每个新到达的进程都可以很快得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度。
                    缺点
                是否会导致饥饿
                    会
        16.进程同步和互斥
            进程同步
                并发性带来了异步性，有时需要通过进程同步解决这种异步问题。有的进程之间需要相互配合地完成工作，各进程的工作推进需要遵循一定的先后顺序
            进程互斥
                概念
                    对临界资源的访问，需要互斥的进行。即同一时间段内只能允许一个进程访问该资源
                四个部分
                    进入区
                        检查是否可进入临界区，若可进入，需要“上锁”
                    临界区
                        访问临界资源的那段代码
                    退出区
                        负责“解锁”
                    剩余区
                        其余代码部分
                需要遵循的原则
                    空闲让进
                        临界区空闲时，应允许一个进程访问
                    忙则等待
                        临界区正在被访问时，其他试图访问的进程需要等待
                    有限等待
                        要在有限时间内进入临界区，保证不会饥饿
                    让权等待
                        进不了临界区的进程，需要释放处理机，防止忙等
            进程互斥的软件实现方法
                单标志法
                双标志先检查
                双标志后检查
                Peterson算法
            进程互斥的硬件实现方法
                中断屏蔽方法
                    使用“开/关中断”指令实现
                    优点；简单高效
                    缺点：只适用于单处理机；只适用于操作系统内核进程
                TestAndSet（TS指令/TSL指令）
                Swap指令（XCHG指令）
        17.信号量机制
            整型信号量
                用一个整数型变量作为信号量，数值表示某种资源数
                整型信号量与普通整型变量的区别：对信号量只能执行初始化、P、V三种操作
                整型信号量存在的问题：不满足让权等待原则
                数据结构
            记录型信号量
                S.value表示某种资源数，S.L指向等待该资源的队列
                P操作中，一定是先S.value--，之后可能需要执行block原语
                V操作中，一定是先S.value++，之后可能需要执行wakeup原语
                注意：要能够直接推断在什么条件下需要执行block或wakeup
                可以用记录型信号量实现系统资源的“申请”和“释放”
                可以用记录型信号量实现进程互斥、进程同步
                数据结构
            实现进程互斥
                分析问题，确定临界区
                设置互斥信号量，初值为1
                临界区之前对信号量执行P操作
                临界区之后对信号量执行V操作
            实现进程同步
                分析问题，找出哪里需要实现“一前一后”的 同步关系
                设置同步信号量，初始值为0
                在“前操作”之后执行V操作
                在“后操作”之前执行P操作
            实现进程的前驱关系
                分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题
                为每一对前驱关系设置同步信号量，初始值为0
                在每个“前操作”之后执行V操作
                在每个“后操作”之前执行P操作
        18.进程互斥同步问题
            生产者消费者问题
                问题描述
                如何实现
            多生产者多消费者问题
                问题描述
                如何实现
                重要思路
            吸烟者问题
                问题描述
                如何实现
            读者写者问题
                问题描述
                如何实现
                    读者优先
                    写者优先（读写公平法）
                重要思路
            哲学家进餐问题
                问题描述
                代码实现
                死锁问题解决
                    1.可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样就可以保证至少有一个哲学家是可以拿到左右两只筷子的
                    2.要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起一只筷子，另一个会阻塞
                    3.仅当一个哲学家左右两支筷子都可使用时才允许他抓起筷子，为拿起两只筷子的操作前后加上互斥信号量mutex
        19.管程
            为什么要引入管程
                解决信号量机制编程麻烦、易出错的问题
            组成
                共享数据结构
                对数据结构初始化的语句
                一组用来访问数据结构的过程（函数）
            基本特征
                各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据
                每次仅允许一个进程在管程内执行某个内部过程
            补充
                各进程必须互斥访问管程的特性是由编译器实现的
                可在管程中设置条件变量及等待/唤醒操作以解决同步问题
        20.死锁
            死锁、饥饿、死循环的区别
                死锁：至少是两个进程一起死锁，死锁进程处于阻塞态
                饥饿：可以只有一个进程饥饿，饥饿进程可能阻塞也可能就绪
                死循环：可能只有一个进程发生死循环，死循环是应用程序员要解决的
                死锁和饥饿是操作系统要解决的问题，死循环是应用程序员要解决的
            死锁产生的必要条件
                互斥条件
                    对必须互斥使用的资源的争抢才会导致死锁
                不剥夺条件
                    进程保持的资源只能主动释放，不可强行剥夺
                请求和保持条件
                    保持着某些资源不放的同时，请求别的资源
                循环等待条件
                    存在一种进程资源的循环等待链
                    循环等待未必死锁，死锁一定有循环等待
            什么时候会发生死锁
                对不可剥夺资源的不合理分配，可能导致死锁
            死锁的处理策略
                预防死锁
                    破坏死锁产生的四个必要条件
                避免死锁
                    避免系统进入不安全状态（银行家算法）
                死锁的检测和解除
                    允许死锁发生，系统负责检测出死锁并解除
        21.死锁的处理
            预防死锁
                破坏互斥条件
                    将临界资源改造为可共享使用的资源（如SPOOLing技术）
                    缺点：可行性不高，很多时候无法破坏互斥条件
                破坏不剥夺条件
                    方案一，申请的资源得不到满足时，立即释放拥有的所有资源
                    方案二，申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）
                    缺点：实现复杂；剥夺资源可能导致部分工作失效；反复申请和释放导致系统开销大；可能导致饥饿
                破坏请求和保持条件
                    运行前分配好所有需要的资源，之后一直保持
                    缺点：资源利用率低；可能导致饥饿
                破坏循环等待条件
                    给资源编号，必须按编号从小到大的顺序申请资源
                    缺点：不方便增加新设备；会导致资源浪费；用户编程麻烦
            避免死锁
                什么是安全序列
                    所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。
                什么是系统的不安全状态，与死锁有何联系
                    如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有的进程都无法顺利的执行下去。如果有进程提前归还了一些资源，系统也有可能重新回到安全状态。
                如何避免系统进入不安全状态--银行家算法
            检测和解除
                死锁的检测
                    数据结构：资源分配图
                        两种结点
                            进程结点
                            资源结点
                        两种边
                            进程结点——>资源结点（请求边）
                            资源节点——>进程结点（分配边）
                    死锁检测算法
                        依次消除与不阻塞进程相连的边，直到无边可消
                        注：所谓不阻塞进程是指其申请的资源数还足够的进程
                        死锁定理：若资源分配图是不可完全简化的，说明发生了死锁
                死锁的解除
                    资源剥夺法
                    撤销进程法（终止进程法）
                    进程回退法
    计算机操作系统进程管理
        进程线程
            2、进程的状态与转换
            1、典型调度算法
                时间片轮转
                先来先服务调度算法
                短作业(短进程、短线程)优先调度算法
                优先级调度算法
                高响应比优先调度算法
                多级反馈队列调度算法
            2，处理机调度
                2、调度时机、切换与过程
                3、调度的基本准则
                4、调度方式
                    批处理系统
                    交互式系统
                    实时系统
            3，进程通信
                共享存储系统;;。
                信号量
                套接字
                消息传递系统
                管道通信
            4，进程的问题
                （三）同步与互斥
                    2、实现临界区互斥的基本方法
                        软件实现方法;硬件实现方法。
                    3、信号量
                    4、管程
                    5、经典同步问题
                        生产者-消费者问题;读者-写者问题;哲学家进餐问题。
                （四）死锁
                    2、死锁处理策略
                    3、死锁预防
                    4、死锁避免
                        系统安全状态，银行家算法。
                    5、死锁检测和解除
        进程问题层级
            多进程的配合使用
                分步实施事务
                事务问题
            多进程的资源问题
                分布式锁的问题
                锁的问题
            中断的问题
            本质
                消息通讯结构
                存储数据结构
        进程和线程的使用
            进程和线程的选择
                ### 多进程还是多线程取决于
                    任务数量
                    任务类型
                        计算密集型任务
                            是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。
                        I/O密集型任务
                            除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。
                ### 单线程+异步I/O
                    现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。
                    在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。