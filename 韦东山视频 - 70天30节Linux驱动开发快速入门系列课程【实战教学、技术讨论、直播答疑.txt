70天30节Linux驱动开发快速入门系列课程【实战教学、技术讨论、直播答疑

P1.1_单片机程序和Linux程序的分层  40:24 
P2  1.2_Linux应用程序和驱动程序的接口  22:28 
P3  1.3_字符设备驱动程序框架  24:56 
P4  1.4_深入与答疑  28:46 
P5  2.1_字符设备驱动回顾与数据流程  20:22 
P6  2.2_入口出口细讲 34:36
P7.3_字符设备调用关系实验  30:47 
P8  2.4_数据交互  28:34 
P9  2.5_调试  35:41 
P10  3.1_驱动程序框架回顾_地址空间问题引入  12:04 
P11  3.2_地址片选与虚拟地址的引入  20:08 
P12  3.3_为什么需要虚拟地址  09:04 
P13  3.4_class_create_device_create  18:11 
P14  3.5_答疑  19:13 
P15  4.1_LED驱动程序分析  15:35 
P16  4.2_在内核目录外编译模块  09:14 
P17  4.3_在内核目录里编译驱动  26:28 
P18  4.4_答疑1  31:36 
P19  4.5_答疑2  14:42 
P20  4.6_答疑3  25:02 
P21  5.1_引入分离的思想和总线设备驱动模型  24:39 
P22  5.2_总线设备模型下驱动程序的编写方法  18:24 
P23  5.3_匹配过程  08:37   P24   5.4_platform_driver_platform_device万能膏药  05:50 
P25  5.5_驱动的两种写法的比较  36:28 
P26  5.6_应用场景和答疑  36:23 
P27  6.1_字符设备和总线设备驱动模型回顾  10:21 
P28  6.2_使用总线设备驱动模型的驱动程序分析  11:50 
P29  6.3_上机实验  10:32 
P30  6.4_匹配(match)方法  23:27   P31   6.5_platform_device注册过程分析  18:25 
P32  6.6_闲聊学习方法_私有数据  06:44 
P33  6.7_答疑  15:45 
P34  7.1_设备树的引入  08:31 
P35  7.2_创建设备树节点示例  19:09 
P36  7.3_设备树节点匹配过程  19:11 
P37  7.4_调试与完善  12:38 
P38  7.5_再次对比单片机驱动和Linux驱动  07:16 
P39  7.6_答疑  39:02 
P40  8.1_LED和按键的设备树示例  29:15 
P41  8.2_I2C设备树示例  20:38   P42   8.3_SPI设备树示例  11:57 
P43  8.4_LCD设备树示例  17:06 
P44  8.5_怎么写设备树  15:18 
P45  8.6_学习方法闲聊  20:53   P46   9.1_Pinctrl概念介绍  15:56   P47   9.2_不同板子的Pinctrl信息对比  17:51   P48   9.3_不同板子的GPIO信息对比  16:55 
P49  9.4_LED和网卡设备树示例  20:23 
P50  9.5_声卡设备树示例  30:22 
P51  9.6_答疑  22:02 
P52  10.1_应用程序和驱动程序交互的4种方式  16:05   P53   10.2_中断的处理及APP的关系  15:02 
P54  10.3_中断系统的设备树分析  38:00 
P55  10.4_中断驱动编写示例  48:41 
P56  10.5_调试  10:38 
P57  11.1_字符设备开发总结  17:10 
P58  11.2_非阻塞方式流程分析  08:34 
P59  11.3_休眠唤醒流程分析  18:01   P60   11.4_poll机制流程分析  20:58 
P61  11.5_异步通知机制流程分析  16:46 
P62  11.6_信号处理内部机制  22:20 
P63  11.7_答疑  38:50   P64   12.1_poll答疑  07:36 
P65  12.2_硬件中断号与虚拟中断号  25:38 
P66  12.3_答疑  1:33:08 
P67  13.1_需求分析  14:26 
P68  13.2_实现设备树节点  21:15 
P69  13.3_实现驱动框架  22:02 
P70  13.4_上机实验  27:12 
P71  13.5_答疑  37:15 
P72  14.1_注册SR501字符设备驱动  23:11   P73   14.2_实现SR501驱动的probe函数  08:44 
P74  14.3_实现SR501驱动的read函数  05:30 
P75  14.4_单片机中断和Linux中断的简单比较  09:37 
P76  14.5_实现SR501驱动的中断功能  10:25 
P77  14.6_实现SR501的休眠唤醒  30:45 
P78  15.1_SR501驱动程序作业解析  09:11 
P79  15.2_答疑  12:40 
P80  15.3_完善SR501驱动程序  24:53 
P81  15.4_SR501上机实验  17:13 
P82  15.5_内核线程的引入  10:29 
P83  15.6_编写内核线程代码  25:53 
P84  15.7_答疑闲聊  06:48 
P85  16.1_讲解完整的SR501驱动程序  10:34 
P86  16.2_内核线程代码示例  07:57 
P87  16.3_创建内核线程_无法休眠  11:25 
P88  16.4_解决无法休眠的问题  07:31 
P89  16.5_解决内核线程无法停止的问题  10:10 
P90  16.6_答疑  36:49 
P91  16.7_中断深度答疑  19:31 
P92  17.1_SR04超声波测距模块驱动编写思路  15:59 
P93  17.2_方法1_关中断查询  20:39 
P94  17.3_方法1_上机测试  23:52 
P95  17.4_方法2_使用中断  27:37 
P96  17.5_答疑  02:32 
P97  17.6_调试  09:23 
P98  18.1_DHT11温湿度传感器驱动程序编程思路  16:28 
P99  18.2_编写驱动_方法1_查询  34:11 
P100  18.3_上机调试_引脚输出时不该再设置方向  34:39 
P101  18.4_上机调试_发现时间不准  11:10 
P102  19.1_纯软件调试DHT11驱动  38:25 
P103  19.2_使用逻辑分析仪调试DHT11驱动  31:18 
P104  20.1_使用中断编写DHT11驱动的思路  10:04 
P105  20.2_使用中断来编写DHT11驱动  27:40 
P106  20.3_IMX6ULL中断丢失导致DHT11数据解析失败  55:25 
P107  20.4_IIO驱动之DHT11简单分析  05:55   P108   20.5_在STM32MP157上实验成功  18:45 
P109  21.1_DS18B20驱动编程思路  27:00 
P110  21.2_DS18B20驱动编写_框架  23:16 
P111  21.3_DS18B20驱动编写_完善  29:14 
P112  21.4_DS18B20驱动调试  25:35 
P113  21.5_下次课预习_输入子系统  01:14 
P114  22.1_红外遥控器HS0038驱动编程思路  20:56 
P115  22.2_HS0038驱动_注册中断  10:10 
P116  22.3_HS0038驱动_怎么判断数据的完整性  07:22 
P117  22.4_HS0038驱动_解析数据  41:51 
P118  22.5_答疑  14:22 
P119  23.1_成功解析HS0038的数据  23:21 
P120  23.2_使用环形缓冲区的思路  08:06 
P121  23.3_完善HS0038驱动  16:03 
P122  23.4_使用输入子系统编写HS0038驱动  31:24 
P123  23.5_输入子系统驱动程序简单分析  14:18 
P124  23.6_答疑与预习  10:33 
P125  24.1_I2C总线设备驱动模型  18:24 
P126  24.2_编写AT24C02驱动框架  30:33   P127   24.3_上机测试_无法probe  19:51 
P128  24.4_调试1_添加打印信息  48:02 
P129  24.5_调试2_发现内核缺陷  12:45 
P130  25.1_AT24C02驱动编写思路  20:53 
P131  25.2_AT24C02驱动编写程序  36:49 
P132  25.3_AT24C02驱动上机调试  32:32 
P133  26.1_I2C和输入系统的结合  17:04 
P134  26.2_I2C设备作为输入设备的驱动注册流程  11:38 
P135  26.3_输入设备注册过程代码分析  07:10   P136   26.4_输入设备open_read过程代码分析  11:37 
P137  26.5_gt9xx驱动代码分析  14:34 
P138  26.6_答疑  16:51 
P139  26.7_FT5x06驱动代码分析  08:19 
P140  26.8_预习  05:18   P141   27.1_SPI驱动程序开发流程  23:41 
P142  27.2_构造设备树节点  13:03   P143   27.3_解决无法创建spi设备  27:08   P144   27.4_解决无法probe  07:41   P145   27.5_SPI字符设备驱动框架  28:27 
P146  28.1_编写OLED操作函数  24:13 
P147  28.2_成功清屏  19:44 
P148  28.3_实现ioctl  09:24   P149   28.4_编写APP并改进驱动  22:29 
P150  28.5_上机测试  09:03 
P151  28.6_DAC模块程序编程及上机  27:26   P152   28.7_DAC调试_SPI模式_pol_pha  18:17 
P153  28.8_DAC调试_使用逻辑分析仪发现内核bug  20:38 
P154  29.1_LCD硬件操作原理与调试思路  20:10   P155   29.2_SPI_OLED怎么使用Framebuffer  11:57 
P156  30.1_回顾Framebuffer驱动的编写方法  07:14 
P157  30.2_编写Framebuffer驱动程序框架  24:17 
P158  30.3_编译调试  16:04 
P159  30.4_框架调试成功  31:45 
P160  30.5_增加内核线程  25:50 
P161  30.6_调试OLED无反应
04:10