select-poll-epoll

select，poll，epoll都是IO多路复用机制，即可以监视多个描述符，
一旦某个描述符就绪（读或写就绪），能够通知程序进行相应读写操作。 

但select，poll，epoll本质上都是###同步I/O####
因为他们都需要在读写事件就绪后自己负责进行读写，
也就是说这个读写过程是阻塞的，
而异步I/O则无需自己负责进行读写，
异步I/O的实现会负责把数据从内核拷贝到用户空间。

select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。


而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，
但是它是设备就绪时，调用###回调函数####，把就绪fd放入就绪链表中，
并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，
但是select和poll在“醒着”的时候要遍历整个fd集合，
而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。

这就是回调机制带来的性能提升。
select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，
而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，

注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。
这也能节省不少的开销。


理解：
睡觉可以减少CPU的开销


总结：
            epoll         selectpoll
执行机制： 回调函数放fd就绪      轮询fd集合
轮询       轮询就绪的fd链表   整个fd集合
拷贝       不拷贝多遍     每次轮询都拷贝fd
数据结构     红黑树       数组/链表 

都是同步的，都需要用户线程进行任务的处理
